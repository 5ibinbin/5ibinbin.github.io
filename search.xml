<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[AngularJs 输入框自动变化高度]]></title>
      <url>%2F2017%2F06%2F22%2FAngularJs%20%E8%BE%93%E5%85%A5%E6%A1%86%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E9%AB%98%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[### 当你想实现一个高度自增长的文本框的时候，也许你首先想到的是textarea，但是使用它太麻烦而且还会有很多问题，下面我们来介绍一种简单有效的方式。 div div中有个属性contenteditable，当把它设为true的时候，这个div就会变为可编辑状态，所以我们可以利用这个属性来使div变为文本域，下面看代码 html &lt;div contenteditable=&quot;true&quot; id=&quot;article-comment-content&quot; class=&quot;article-comment-content&quot; onblur=&quot;contentBlur()&quot; ng-model=&quot;vm.articleComment.content&quot;&gt;&lt;/div&gt; css .article-comment-content{ padding: 10px; line-height: 20px; font-size: 14px; background: white; -webkit-user-select: text; } .article-comment-content:empty:before { content: &apos;请输入回帖内容&apos;; color: #999; } .article-comment-content:focus:before { content: none; } 以上我们实现了文本输入框并自动增加文本框的高度，并设置了文本框的placeholder。但是细心的你可能要问了，应该怎么实现数据绑定呢？下面我们接着来看这个问题： 其实我们可以通过 var content = $(‘#article-comment-content’).eq(0)[0].textContent 来获取输入框的值，但是这样是不能进行双向数据绑定的。对于这个问题我们可以使用自定义指令的方式.directive(&apos;contenteditable&apos;, function () { return { require: &apos;ngModel&apos;, link: function (scope, element, attrs, ctrl) { element.bind(&apos;input&apos;, function () { scope.$apply(function () { ctrl.$setViewValue(element.html()); }); }); ctrl.$render = function () { element.html(ctrl.$viewValue); }; } }; }); 或者 app.directive(&apos;contenteditable&apos;, function() { return { restrict: &apos;A&apos;, // 只用于属性 require: &apos;?ngModel&apos;, link: function(scope, element, attrs, ngModel) { if (!ngModel) { return; } ngModel.$render = function() { element.html(ngModel.$viewValue || &apos;&apos;); }; element.on(&apos;blur keyup change input&apos;, function() { scope.$apply(readViewText); }); function readViewText() { var html = element.html(); if (attrs.stripBr &amp;&amp; html === &apos;&lt;br&gt;&apos;) { html = &apos;&apos;; } ngModel.$setViewValue(html); } } }; 这样我们就可以实现数据的双向绑定了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native 自定义组件]]></title>
      <url>%2F2017%2F06%2F21%2FReact%20Native%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[通过继承Component来创建组件类 class TextButton extends Component { } 定义组件的propTypes(props类型)和defaultProps(props默认值) static propTypes = { text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number }; static defaultProps = { color: &apos;white&apos;, backgroundColor: &apos;#FFDE00&apos;, fontSize:14 }; 其中PropTypes的类型有：array，bool，func，number，object， string，symbol 渲染界面，引用props值 render() { return ( &lt;TouchableOpacity onPress={this.props.onPress}&gt; &lt;View style={[{backgroundColor:this.props.backgroundColor}]}&gt; &lt;Text style={{fontSize:this.props.fontSize, color:this.props.color}}&gt;{this.props.text}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) } 导出组件 export default TextButton; 下面是完整代码：&apos;use strict&apos;; import React, {Component, PropTypes} from &apos;react&apos;; import { StyleSheet, TouchableOpacity, Text, View } from &apos;react-native&apos;; class TextButton extends Component { static propTypes = { text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number }; static defaultProps = { color: &apos;white&apos;, backgroundColor: &apos;#FFDE00&apos;, fontSize:14 }; render() { return ( &lt;TouchableOpacity onPress={this.props.onPress}&gt; &lt;View style={[{backgroundColor:this.props.backgroundColor}]}&gt; &lt;Text style={{fontSize:this.props.fontSize, color:this.props.color}}&gt;{this.props.text}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) } } export default TextButton; 引用//首先导入组件 import TextButton from &apos;../component/TextButton&apos;; //然后在render渲染 &lt;TextButton style={styles.register} text={&apos;测试文字&apos;} onPress={() =&gt; this._test()} color={&apos;#FFDE00&apos;} backgroundColor={&apos;transparent&apos;}/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native探索与设计(二)-JSX语法和ES6语法]]></title>
      <url>%2F2017%2F06%2F21%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[JSX语法 JSX: 即JavaScript XML 是一种在React组建内部构建标签的类XML语法。增强React程序组件的可读性 React的核心机制之一就是虚拟DOM: 可以在内存中创建虚拟DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。1、示例render: function() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; Welcome to React Native! &lt;/Text&gt; &lt;/View&gt; ); } 2、JS表达式 ReactJS中约定自定义的组件标签首字母一定要大写，这样区别于HTML标签 表达式用{}包起来，不要加引号，加引号就会被当成字符串。 JSX是HTML和JavaScript混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析 3、关于样式 普通内联样式:&#123;&#123;&#125;&#125;,第一层{}是表达式，第二层{}是js对象 &lt;View style={{fontSize:40, width:80,}}&gt; &lt;/View&gt; 调用样式表:{样式类.属性} &lt;View style={styles.container}&gt;&lt;/View&gt; 样式表和内联样式共存:{[]} &lt;View style={[styles.container, {fontSize:40, width:80}]}&gt; 多个样式表:{[样式类1， 样式类2]} &lt;View style={[styles.container, styles.color]}&gt; ES6语法 展开运算符：允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。 用于函数调用myFunction(...iterableObj); 用于数组字面量[...iterableObj, 4, 5, 6] apply方法能劫持另外一个对象的方法，继承另外一个对象的属性 function myFunction(x, y, z) { } var args = [0, 1, 2]; myFunction.apply(null, args); 这是使用了apply方法来遍历的参数，但是在ES6下我们还可以像下面这样写 function myFunction(x, y, z) { } var args = [0, 1, 2]; myFunction(...args); 数组字面量展开操作符可以简化数组间的操作如下： var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2); 可以将一个数组在任何位置插入另一个数组： var arr1 = [3, 4]; var lyrics = [2, ...arr1, 5, 6]; 解构赋值解构赋值是ES6的特性 let [arg1,arg2,...arg3] = [1, 2, 3, 4]; arg1 //1 arg2 //2 arg3 //[&apos;3&apos;,&apos;4&apos;] 解构赋值中展开运算符只能放在最后 let [arg1,...arg2,arg3] = [1, 2, 3, 4]; //报错 箭头函数(Arrow Functions)：箭头函数的产生主要有两个目的更：简洁的语法和与父作用域共享关键字this 简洁x =&gt; x * x相当于123function (x) &#123; return x * x;&#125; 无参数1() =&gt; 5 一个参数1x =&gt; x * x 两个参数1(x, y) =&gt; x * y 可变参数1234567(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 返回对象1x =&gt; (&#123; foo: x &#125;) 通过上面的一些格式，我们可以看出函数体的内容和普通的函数比更简洁 this每个新定义的函数都有其自己的 this 值，我们通过下面几段代码来看看this的作用域问题：123456function Person() &#123; this.age = 0; //this 指向的就是对象自己 setInterval(function growUp() &#123; this.age++; // 在非严格模式下，this指向的是函数内部 &#125;, 1000);&#125; 可以通过新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。1234567function Person() &#123; var that = this; that.age = 0; //that 指向的就是对象自己 setInterval(function growUp() &#123; that.age++; //that指向的是我们期望的指向 &#125;, 1000);&#125; 用箭头函数就可以这么写：123456function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向了 person 对象 &#125;, 1000);&#125; argument变量箭头函数与普通函数还有一个区别就是，它没有自己的arguments变量 React Native中也用到了ES6的let, const, import, class，所以开发前最好先对这些基础知识有个了解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native探索与设计(三)]]></title>
      <url>%2F2017%2F06%2F21%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%B8%89)%2F</url>
      <content type="text"><![CDATA[很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。 引用 在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样： //ES5 var React = require(&quot;react-native&quot;); var { Image, Text, PropTypes } = React; //引用不同的React Native组件 在ES6里，import写法更为标准 //ES6 import React, { Image, Text, PropTypes } from &apos;react-native&apos;; 注意在React Native里，import直到0.12+才能正常运作。 导出单个类 在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出 //ES5 var MyComponent = React.createClass({ ... }); module.exports = MyComponent; 在ES6里，通常用export default来实现相同的功能： //ES6 export default class MyComponent extends React.Component{ ... } 引用的时候也类似： //ES5 var MyComponent = require(&apos;./MyComponent.js&apos;); //ES6 import MyComponent from &apos;./MyComponent.js&apos;; 定义组件 在ES5里，通常通过React.createClass来定义一个组件类，像这样： //ES5 var Photo = React.createClass({ render: function() { return ( &lt;Image source={this.props.source} /&gt; ); }, }); 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样： //ES6 class Photo extends React.Component { render() { return ( &lt;Image source={this.props.source} /&gt; ); } } 给组件定义方法 从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。 //ES5 var Photo = React.createClass({ componentWillMount: function(){ }, render: function() { return ( &lt;Image source={this.props.source} /&gt; ); }, }); //ES6 class Photo extends React.Component { componentWillMount() { } render() { return ( &lt;Image source={this.props.source} /&gt; ); } } 定义组件的属性类型和默认属性 在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现 //ES5 var Video = React.createClass({ getDefaultProps: function() { return { autoPlay: false, maxLoops: 10, }; }, propTypes: { autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, }, render: function() { return ( &lt;View /&gt; ); }, }); 在ES6里，可以统一使用static成员来实现 //ES6 class Video extends React.Component { static defaultProps = { autoPlay: false, maxLoops: 10, }; // 注意这里有分号 static propTypes = { autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, }; // 注意这里有分号 render() { return ( &lt;View /&gt; ); } // 注意这里既没有分号也没有逗号 } 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思： //ES6 class Video extends React.Component { render() { return ( &lt;View /&gt; ); } } Video.defaultProps = { autoPlay: false, maxLoops: 10, }; Video.propTypes = { autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, }; 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化STATE ES5下情况类似， //ES5 var Video = React.createClass({ getInitialState: function() { return { loopsRemaining: this.props.maxLoops, }; }, }) ES6下，有两种写法： //ES6 class Video extends React.Component { state = { loopsRemaining: this.props.maxLoops, } } 推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）： //ES6 class Video extends React.Component { constructor(props){ super(props); this.state = { loopsRemaining: this.props.maxLoops, }; } } 把方法作为回调提供 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 //ES5 var PostInfo = React.createClass({ handleOptionsButtonClick: function(e) { // Here, &apos;this&apos; refers to the component instance. this.setState({showOptionsModal: true}); }, render: function(){ return ( &lt;TouchableHighlight onPress={this.handleOptionsButtonClick}&gt; &lt;Text&gt;{this.props.label}&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) }, }); 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用 //ES6 class PostInfo extends React.Component { handleOptionsButtonClick(e){ this.setState({showOptionsModal: true}); } render(){ return ( &lt;TouchableHighlight onPress={this.handleOptionsButtonClick.bind(this)} onPress={e=&gt;this.handleOptionsButtonClick(e)} &gt; &lt;Text&gt;{this.props.label}&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) }, } 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 // 错误的做法 class PauseMenu extends React.Component{ componentWillMount(){ AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused.bind(this)); } componentDidUnmount(){ AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused.bind(this)); } onAppPaused(event){ } } // 正确的做法 class PauseMenu extends React.Component{ constructor(props){ super(props); this._onAppPaused = this.onAppPaused.bind(this); } componentWillMount(){ AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused); } componentDidUnmount(){ AppStateIOS.removeEventListener(&apos;change&apos;, this._onAppPaused); } onAppPaused(event){ } } 从这个帖子中我们还学习到一种新的做法： // 正确的做法 class PauseMenu extends React.Component{ componentWillMount(){ AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused); } componentDidUnmount(){ AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused); } onAppPaused = (event) =&gt; { //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针 } } Mixins 在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;); React.createClass({ mixins: [PureRenderMixin], render: function() { return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;; } }); 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。尽管如果要继续使用mixin，还是有一些第三方的方案可以用.不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，上文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式： //Enhance.js import { Component } from &quot;React&quot;; export var Enhance = ComposedComponent =&gt; class extends Component { constructor() { this.state = { data: null }; } componentDidMount() { this.setState({ data: &apos;Hello&apos; }); } render() { return &lt;ComposedComponent {...this.props} data={this.state.data} /&gt;; } }; //HigherOrderComponent.js import { Enhance } from &quot;./Enhance&quot;; class MyComponent { render() { if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;; return &lt;div&gt;{this.data}&lt;/div&gt;; } } export default Enhance(MyComponent); // Enhanced component 用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ES6+带来的其它好处 ######解构&amp;属性延展 结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签： class AutoloadingPostsGrid extends React.Component { render() { var { className, ...others, // contains all properties of this.props except for className } = this.props; return ( &lt;div className={className}&gt; &lt;PostsGrid {...others} /&gt; &lt;button onClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt; &lt;/div&gt; ); } } React Native 的ES5/ES6写法对照表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native AsyncStorage 封装]]></title>
      <url>%2F2017%2F06%2F20%2FReact%20Native%20AsyncStorage%20%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[在Android开发中有一个以key-value形式轻量级的数据存储方式—SharedPreferences, 类似的React Native中也有一个–AsyncStorage AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的 APIstatic getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) 读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) 将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) 删除一个字段。返回一个Promise对象。 封装&apos;use strict&apos;; import {Component} from &apos;react&apos;; import { AsyncStorage } from &apos;react-native&apos;; import JsonUtil from &apos;../utils/JsonUtil&apos; class StorageUtil extends Component { /* * 保存 * */ static save(key, value, callback) { return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value), callback); } /* * 获取 * */ static get(key) { return AsyncStorage.getItem(key).then((value) =&gt; { const jsonValue = JsonUtil.strToJson(value); return jsonValue; }) } /* * 更新 * */ static update(key, value) { StorageUtil.get(key).then((item) =&gt; { value = typeof value === &apos;string&apos; ? value : Object.assign({}, item, value); return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value)); }) } /* * 删除 * */ static delete(key, callback) { AsyncStorage.removeItem(key, callback); } } export default StorageUtil; 其中JsonUtil是封装的一个Json格式转换的工具类，其中保存和删除添加了一个回调函数 调用保存StorageUtil.save(&apos;sessionToken&apos;, res.sessionToken, function () { console.log(&apos;成功&apos;); }); 调用 StorageUtil.get(&apos;sessionToken&apos;).then((username) =&gt; { this.setState({ username:username }) });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native网络请求和Json-String封装]]></title>
      <url>%2F2017%2F06%2F20%2FReact%20Native%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[Serialization&apos;use strict&apos;; import React, {Component} from &apos;react&apos;; class JsonUtil extends Component { /* * 字符转换为JSON * */ static strToJson(data) { return JSON.parse(data); } /* * JSON转换为字符 * */ static jsonToStr(data) { return JSON.stringify(data); } /* * map转换为json * */ static mapToJson(map) { return JSON.stringify(JsonUtil.strMapToObj(map)); } /* * json转换为map * */ static jsonToMap(jsonStr) { return JsonUtil.objToStrMap(JSON.parse(jsonStr)); } /* * map转化为对象（map所有键都是字符串，可以将其转换为对象） * */ static strMapToObj(strMap) { let obj = Object.create(null); for (let [k, v] of strMap) { obj[k] = v; } return obj; } /* * 对象转换为Map * */ static objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } } export default JsonUtil; 网络请求&apos;use strict&apos;; import React, {Component} from &apos;react&apos;; class NetUtil extends Component { static DouB_Api = &apos;https://api.douban.com/v2/movie/top250?start=0&amp;count=20&apos;; /** * get请求 *url : 请求地址 *callback : 回调函数 */ static get(url, callback) { var fetchOptions = { method: &apos;GET&apos;, headers: { &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; } }; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)); }).done(); } /** * delete请求 *url : 请求地址 *callback : 回调函数 */ static delete(url, callback) { var fetchOptions = { method: &apos;DELETE&apos;, headers: { &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; } }; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)); }).done(); } /** * post请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */ static postJson(url, data, callback) { var fetchOption = { method: &apos;POST&apos;, headers: { &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; }, body: JSON.stringify(data) }; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)) }) .done(); } /** * put请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */ static putJson(url, data, callback) { var fetchOption = { method: &apos;PUT&apos;, headers: { &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; }, body: JSON.stringify(data) }; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)) }) .done(); } export default NetUtil; 网络请求使用import NetUtil from &apos;../utils/NetUtil&apos;; import JsonUtil from &apos;../utils/JsonUtil&apos;; _getMyNoteBook = () =&gt; { let _this = this; let username = this.state.username; let params = { &quot;author&quot;: username }; let url = Global.NOTEBOOK + JsonUtil.jsonToStr(params); NetUtil.get(url, function (response) { console.log(response); _this.setState({ notebooks: _this.state.notebooks.cloneWithRows(response.results), noteArray: response.results }); }); };]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native TextInput 高度自适应]]></title>
      <url>%2F2017%2F06%2F18%2FReact%20Native%20TextInput%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
      <content type="text"><![CDATA[有时我们需要根据默认的文字来显示TextInput的高度，而且可以随着文字的输入自动增加TextInput的高度。下面我们就来看一下这个是如何实现的： TextInput属性介绍代码伺候(去除无关代码)/** * Created by Cral-Gates on 2017/5/11. */ import React, {Component} from &apos;react&apos;; import { StyleSheet, Text, View, TextInput, ScrollView } from &apos;react-native&apos;; import NavigationBar from &apos;../component/NavigationBar&apos;; import NetUtil from &apos;../utils/NetUtil&apos;; import Global from &apos;../utils/Global&apos;; class NoteDetail extends Component { constructor(props) { super(props); this.state = { noteContent: &apos;&apos;, height: 50, } } componentDidMount() { this.setState({ noteContent: this.props.noteDetail.content, }); } render() { return ( &lt;View&gt; &lt;ScrollView&gt; &lt;TextInput style={[styles.noteDetailContent, {height: this.state.height}]} multiline={true} secureTextEntry={false} underlineColorAndroid={&apos;transparent&apos;} value={this.state.noteContent} onChangeText={(noteContent) =&gt; this.setState({noteContent})} onChange={() =&gt; this.onChange.bind(this)} onContentSizeChange={(event) =&gt; this.onContentSizeChange(event)}/&gt; &lt;/ScrollView&gt; &lt;/View&gt; ) } onChange = (event) =&gt; { this.setState({ noteContent: event.nativeEvent.text, height: event.nativeEvent.contentSize.height }); }; onContentSizeChange = (event) =&gt; { this.setState({ height: event.nativeEvent.contentSize.height }); } } const styles = StyleSheet.create({ container: { backgroundColor: &apos;#f5f5f5&apos; }, noteDetailTitle: { backgroundColor: &apos;white&apos;, marginTop: 10, marginBottom: 2, marginLeft: 20, marginRight: 20, height: 35, fontSize: 18, fontWeight: &apos;600&apos; }, noteDetailContent: { backgroundColor: &apos;white&apos;, marginLeft: 20, marginRight: 10, lineHeight: 20, fontSize: 16 } }); export default NoteDetail; 首先创建构造函数 constructor(props) { super(props); this.state = { noteContent: &apos;&apos;, //笔记内容 height: 50, //默认高度 } } 然后设置默认的笔记内容 componentDidMount() { this.setState({ noteContent: this.props.noteDetail.content // 这是从上一个页面传递过来的值 }); } TextInput属性介绍 &lt;TextInput style={[styles.noteDetailContent, {height: this.state.height}]} multiline={true} secureTextEntry={false} underlineColorAndroid={&apos;transparent&apos;} value={this.state.noteContent} onChangeText={(noteContent) =&gt; this.setState({noteContent})} onChange={() =&gt; this.onChange.bind(this)} onContentSizeChange={(event) =&gt; this.onContentSizeChange(event)}/&gt; onChange function 监听方法,文本框内容发生改变回调方法 onChangeText = (text) =&gt; { this.setState({ noteContent: text }) } onChangeText function监听方法，文本框内容发生改变回调方法，该方法主要是监听输入框文字的变化 onChange = (event) =&gt; { this.setState({ noteContent: event.nativeEvent.text }); }; onContentSizeChange function监听方法，当文本框的高度发生变化时回调该方法。当TextInput的高度可变时，调用onLayout方法并将宽高传递给它，并重新绘制该组件。 onContentSizeChange = (event) =&gt; { this.setState({ height: event.nativeEvent.contentSize.height }); } 至此就大功告成了！有什么问题可留言交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native TextInput 属性介绍]]></title>
      <url>%2F2017%2F06%2F18%2FReact%20Native%20TextInput%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[View 支持View的相关属性 autoCapitalize 控制TextInput输入的字符进行切换成大写(可选择参数:’none’, ‘sentences’, ‘words’, ‘characters’) none:不自动切换任何字符成大写 sentences:默认每个句子的首字母变成大写 words:每个单词的首字母变成大写 characters:每个字母全部变成大写 autoCorrect bool 设置拼写自动修正功能 默认为开启(true) autoFocus bool 设置是否默认获取到焦点默认为关闭(false)。该需要componentDidMount方法被调用之后才会获取焦点哦(componentDidMount是React组件被渲染之后React主动回调的方法) defaultValue string 给文本输入设置一个默认初始值。 editable bool 设置文本框是否可以编辑 默认值为true,可以进行编辑 keyboardType 键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的 default numeric 数字键盘 email-address 邮箱地址 maxLength number 可以限制文本输入框最大的输入字符长度 multiline bool 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示) onBlur function 监听方法，文本框失去焦点回调方法 onChange function 监听方法,文本框内容发生改变回调方法 onChangeText function监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容 onEndEditing function监听方法，当文本结束文本输入回调方法 onFocus function 监听方法 文本框获取到焦点回调方法 onLayout function监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height} onSubmitEditing function监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效 placeholder string 当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除 placeholderText Color string 设置默认信息颜色(placeholder) secureTextEntry bool 设置是否为密码安全输入框 ，默认为false style 风格属性 可以参考Text组件风格 value string 输入框中的内容值 以上是一些Android，iOS平台通用的属性，下面根据官网的文档，我这边组要讲解一下适用于Android平台的属性方法 numberOfLines number设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。 textAlign 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’) textAlignVertical 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’) underlineColorAndroid 设置文本输入框下划线的颜色 摘抄自TextInput]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Next 博客搭建资源整理]]></title>
      <url>%2F2017%2F04%2F12%2Fhexo%20%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Next Theme版本5.1.0 hexo博客搭建遇到的问题处理和优化所需的资源 hexo开始搭建 底部Powered By algolia问题 三方服务 Cannot find module ‘hexo-util’ 配置文件属性说明 集成LeanCloud记录次数 hexo next 底部Logo栏(powered by) 添加友言评论 Hexo异常处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android MVC和MVP的区别和理解]]></title>
      <url>%2F2017%2F04%2F11%2FAndroid%20MVC%E4%B8%8EMVP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[MVC架构：MVC就是Model-View-Controller，它们的作用是：(数据模型)Model：数据的封装和保存，业务逻辑和实体模型 (视图)View：视图界面，对应于布局文件 (控制器)Controller：业务逻辑，对应于Activity、Fragment等 它们之间的关系如下图所示：View传送指令到Controller,Controller完成业务逻辑后，改变Model的状态，Model将新的数据发送到View，这就是MVC模式的处理逻辑。 MVP架构：MVP是Model-View-Presenter，它们的作用如下： Model：业务逻辑和实体模型，用来操作实际的数据，包含Bean和Model的抽象接口来降低耦合。 View：就是Android中的视图，需要建立一个View的抽象接口View Interface。通过实现View的接口来实现View与Presenter的交互，从而降低耦合。对应于Activity，负责View的绘制与用户交互； Presenter：View和Model的中间枢纽，处理和用户交互的逻辑。 MVP和MVC的对比：MVP架构：View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。 Presenter与View的交互是通过接口来进行的。 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。 MVC架构：View可以与Model直接交互。 Controller是基于行为的，并且可以被多个View共享。 可以负责决定显示哪个View。 通过一个简单的例子来理解MVP模式：View层： /** * ViewInterface * 定义一些通用的view接口 */ public interface LoadDataView { /*** * 耗时操作，加载数据，显示Progress */ void showLoading(); /*** * 隐藏Progress */ void hideLoading(); } /** * 更细小的，用来显示图书细节的View接口 */ public interface LoadBookView extends LoadDataView { void showDetailsView(BookEntity entity); } /*** * Fragment,属于View层，实现了ViewInterface（LoadBookView） */ public class BookDetailFragment extends Fragment implements LoadBookView{ /**图书条形码ISBN号*/ public static final String ISBN = &quot;9787121060748&quot;; /**持Presenter对象*/ private BookDetailsPresenter presenter; @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); initWidget(); presenter = new BookDetailsPresenter(getActivity(), ISBN); // 实例化一个presenter对象 presenter.setView(this); //让Presenter持一个ViewInterface实例（LoadBookView） presenter.loadData(); //告诉Presenter快给我加载Data } @Override public void showDetailsView(BookEntity entity) { //更新UI等操作 } @Override public void showLoading() { rlProgress.setVisibility(View.VISIBLE); } @Override public void hideLoading() { rlProgress.setVisibility(View.GONE); } } 2、Presenter层： public class BookDetailsPresenter { /**持一个Model层的对象，用来从网页接口Rest Api中提取数据*/ private RestApi restApi = null; /**一个ViewInterface对象，用来回调Data给View*/ private LoadBookView loadBookView; private String isbn; public BookDetailsPresenter(Context context, String isbn) { restApi = new RestApiImpl(context); this.isbn =isbn; } public void setView(LoadBookView loadBookView) { this.loadBookView = loadBookView; } public void loadData() { loadBookView.showLoading(); //耗时操作，开个线程异步的加载数据 Thread thread = new Thread(new Runnable() { @Override public void run() { restApi.getBookDetailByIsbn(isbn, bookDetailsCallback); } }); thread.start(); } //匿名内部类，接收bookDetailCallback的回调数据 private RestApi.BookDetailsCallback bookDetailsCallback = new RestApi.BookDetailsCallback() { @Override public void onBookEntityLoaded(BookEntity bookEntity) { notifyDataLoadedSuccessful(bookEntity); BookDetailsPresenter.this.loadBookView.hideLoading(); } @Override public void onError(Exception e) { //异常后的相关处理 } }; /*** * 通知获取数据成功了，赶快通知UI更新吧 */ private void notifyDataLoadedSuccessful(final BookEntity bookEntity) { Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() { @Override public void run() { BookDetailsPresenter.this.loadBookView.showDetailsView(bookEntity); } }); } } 3、Model层： /*** * 整个应用程序需要的数据实体类 */ public class BookEntity { //一些set，get方法 } /** * 一个接口，用来从rest api api获得数据，它的实现在RestApiImpl中 */ public interface RestApi { String API_ISBN_BASE_URL = &quot;https://api.douban.com/v2/book/isbn/&quot;; /*** * 更细小的接口，用来将获取到的数据，回调给它的调用者 */ interface BookDetailsCallback { void onBookEntityLoaded(BookEntity bookEntity); void onError(Exception e); } /** * 从网络获取数据，然后通过bookDetailCallback回调给Presenter * @param isbn * @param bookDetailsCallback */ void getBookDetailByIsbn(final String isbn, final BookDetailsCallback bookDetailsCallback); } 参考文章：http://www.jianshu.com/p/95c9088eef4f http://www.codeceo.com/article/mvp-android.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android观察者模式]]></title>
      <url>%2F2017%2F04%2F11%2FAndroid%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式理解观察者模式 Observer 观察者模式定义了一个一对多的依赖关系，让多个观察者对象同时监听一个主题对象 当这个主题对象改变时，会通知所有的观察者，让他们能够自动的更新自己 观察者模式的组成 抽象主题：把所有的对观察者对象的引用保存在一个集合中，抽象主题提供一个接口，可以注册和移除观察者； 抽象观察者：为所有的观察者定义一个接口，当主题的数据更新时给登记的观察者提供通知； 具体主题：在具体主题内部状态改变时，给所有登记过的观察者发出通知； 具体观察者：实现抽象观察者提供的更新接口，以便本身的状态能够及时更新； 为便于理解可以把主题理解为被观察者 观察者模式的应用抽象观察者/** * 观察者 */ public interface Observer { void update(); } 抽象主题/** * 主题（发布者、被观察者） */ public interface Subject { /** * 注册观察者 */ void registerObserver(Observer observer); /** * 移除观察者 */ void removeObserver(Observer observer); /** * 通知观察者 */ void notifyObservers(); } 显示当前天气的公告牌的数据(具体观察者)public class CurrentConditionsDisplay implements Observer, DisplayElement { private WeatherData weatherData; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 public CurrentConditionsDisplay(WeatherData weatherData) { this.weatherData = weatherData; this.weatherData.registerObserver(this); } @Override public void display() { System.out.println(&quot;当前温度为：&quot; + this.temperature + &quot;℃&quot;); System.out.println(&quot;当前湿度为：&quot; + this.humidity); System.out.println(&quot;当前气压为：&quot; + this.pressure); } @Override public void update() { this.temperature = this.weatherData.getTemperature(); this.humidity = this.weatherData.getHumidity(); this.pressure = this.weatherData.getPressure(); display(); } } 用于获取数据的具体主题(被观察者)public class WeatherData implements Subject { private List&lt;Observer&gt; observers; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 private List&lt;Float&gt; forecastTemperatures;//未来几天的温度 public WeatherData() { this.observers = new ArrayList&lt;Observer&gt;(); } @Override public void registerObserver(Observer observer) { this.observers.add(observer); } @Override public void removeObserver(Observer observer) { this.observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(); } } public void measurementsChanged() { notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure, List&lt;Float&gt; forecastTemperatures) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; this.forecastTemperatures = forecastTemperatures; measurementsChanged(); } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; } public List&lt;Float&gt; getForecastTemperatures() { return forecastTemperatures; } } 用于公告牌显示的接口(观察者)public interface DisplayElement { void display(); } 公告牌CurrentConditionsDisplay实现了Observer和DisplayElement接口，在他们的构造方法中会调用WeatherData的registerObserver方法将自己注册成观察者，这样被观察者WeatherData就会持有观察者的应用，并将它们保存到一个集合中。当被观察者WeatherData状态发送变化时就会遍历这个集合，循环调用观察者公告牌更新数据的方法。后面如果我们需要增加或者删除公告牌就只需要新增或者删除实现了Observer和DisplayElement接口的公告牌就好了。 参考链接： http://www.cnblogs.com/mengdd/archive/2013/02/07/2908929.html http://www.jianshu.com/p/d55ee6e83d66 ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ionic修改相册插件和监听Android返回]]></title>
      <url>%2F2017%2F04%2F11%2Fionic%E7%9B%91%E5%90%ACAndroid%E8%BF%94%E5%9B%9E%2F</url>
      <content type="text"><![CDATA[ionic混合开发调用Android系统相册，官方的cordova-image-picker插件在直接用的时候会在Android6.0以上的版本由于没有获得相应的存储权限而闪退。 解决方法一： 在原有的cordova插件上面改动，添加了动态授权，我放在了github 用法和原来的相同。 function getImgPicker() { var options = { maximumImagesCount: 1, width: 800, height: 800, quality: 80, title:&apos;&apos;, message:&apos;&apos;, outputType:1 }; window.imagePicker.getPictures(function (results) { vm.userInfo.Url = results[0]; console.log(vm.userInfo.Url); vm.upload(vm.userInfo.Url); }, function (err) { publicMethod.showLoadingNoBackdrop(&apos;调取相册失败&apos;); console.log(angular.toJson(error, true)); }, options); } 解决方法二： 添加一个新的插件，专门获取所需的权限cordova-plugin-android-permissions，下面是用法。 var permissions = cordova.plugins.permissions; permissions.hasPermission(permissions.CAMERA, checkPermissionCallback, null); function checkPermissionCallback(status) { if(!status.hasPermission) { var errorCallback = function() { console.warn(&apos;Camera permission is not turned on&apos;); } permissions.requestPermission( permissions.CAMERA, function(status) { if(!status.hasPermission) errorCallback(); }, errorCallback); } } ionic 监听Android的返回键和双击退出程序(直接上代码) $ionicPlatform.registerBackButtonAction(function (e) { e.preventDefault(); //判断处于哪个页面时双击退出 if ($location.path() == &apos;/tab/home&apos; || $location.path() == &apos;/tab/activity&apos; || $location.path() == &apos;/tab/person&apos; || $location.path() == &apos;/tab/share&apos; || $location.path() == &apos;/tab/study&apos;) { if ($rootScope.backButtonPressedOnceToExit) { ionic.Platform.exitApp(); } else { $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show(&quot;再按一次退出系统&quot;, &quot;short&quot;, &quot;bottom&quot;); $timeout(function () { $rootScope.backButtonPressedOnceToExit = false; }, 2000); } } else if ($location.path() == &apos;/blueprint-list&apos; || $location.path() == &apos;/megagame-list&apos;) { $state.go(&apos;tab.activity&apos;); //此处判断当前所处的View,并返回到tab页 } else if ($ionicHistory.backView()) { $ionicHistory.goBack(); } else { if ($rootScope.backButtonPressedOnceToExit) { ionic.Platform.exitApp(); } else { $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show(&quot;再按一次退出系统&quot;, &quot;short&quot;, &quot;bottom&quot;); $timeout(function () { $rootScope.backButtonPressedOnceToExit = false; }, 2000); } } return false; }, 101);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac跨域]]></title>
      <url>%2F2017%2F04%2F11%2FMac%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[Mac： chrome49以前版本open -a &quot;Google Chrome&quot; --args --disable-web-security chrome49以后版本open -a /Applications/Google\ Chrome.app --args --disable-web-security --user-data-dir Safariopen -a &apos;/Applications/Safari.app&apos; --args --disable-web-security Window： chrome.exe –disable-web-security PS：Mac–&gt;Chrome如果命令行不成功可以安装一个插件Allow-Control-Allow-Origin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ionic固定大小的图片防止变形]]></title>
      <url>%2F2017%2F04%2F11%2FimageCover%2F</url>
      <content type="text"><![CDATA[使用情景：当我们遇到需要固定大小的图片，而又不想让图片变形 这个时候我要应该要想到的是css中的background相关属性 .backImg{ &apos;background-image&apos;: &apos;url(&apos;&apos;)&apos;, &apos;background-size&apos;: &apos;cover&apos;, &apos;background-position&apos;: &apos;center&apos; } //background-size 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 背景图像的某些部分也许无法显示在背景定位区域中。 这样我们就做到了可以让图片局部显示并达到了图片没有变形的效果 下面是AngularJs把它封装为相应的指令 angular.module(&apos;imgTransformModule&apos;, []) .directive(&apos;imgTransform&apos;, function () { return function (scope, element, attrs) { attrs.$observe(&apos;imgTransform&apos;, function (value) { element.css({ &apos;background-image&apos;: &apos;url(&apos; + value + &apos;)&apos;, &apos;background-size&apos;: &apos;cover&apos;, &apos;background-position&apos;: &apos;center&apos; &apos;display&apos;:&apos;inline-block&apos;; }); }); }; }); 调用 &lt;div class=&quot;img-Transform&quot; img-transform=&quot;{{url}}&quot;&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cordova插件开发-Android获取资源Id]]></title>
      <url>%2F2017%2F04%2F10%2FgetResourcesId%2F</url>
      <content type="text"><![CDATA[在制作Cordova插件时不能通过R文件来寻找资源Id，因为R文件是不断变化的，所以我们必须要通过资源名称来获取Id，下面就介绍一下资源id的获取: 使用Resources 类的 getIdentifier方法 通过资源名称虚招布局文件的id private int getResId(String resourceName){ Resources resources = getResources(); int resId = resources.getIdentifier(resourceName,&quot;layout&quot;,getPackageName()); return resId; } 获取字符串id private int getStringId(String stringName){ Resources resources = getResources(); int resId =resources.getIdentifier(stringName,&quot;string&quot;, getPackageName()); return resId; } 获取控件id private int getId(String idName){ Resources resources = getResources(); int resId = resources.getIdentifier(idName, &quot;id&quot;, getPackageName()); return resId; } 获取动画id private int getAnimId(String idName){ Resources resources = getResources(); int resId = resources.getIdentifier(idName, &quot;anim&quot;, getPackageName()); return resId; } 作为一个Android开发者来说，也许你已经发现上面代码的不同点了，就是getIdentifier()里面的第二个参数的不同，我们可以通过替换这个参数来达到大部分的寻找资源id（example：id, string, anim, attr, drawable, layout, color, menu, styles…） 通过Java的强大的反射机制获取资源id 通过反射获取一个资源id public int getAttrId(String attrName) { try { Class&lt;?&gt; loadClass = mContext.getClassLoader().loadClass(mContext.getPackageName() + &quot;.R&quot;); Class&lt;?&gt;[] classes = loadClass.getClasses(); for (int i = 0; i &lt; classes.length; i++) { if (classes[i].getName().equals(mContext.getPackageName() + &quot;.R$attr&quot;)) { Field field = classes[i].getField(attrName); int attrId = field.getInt(null); return attrId; } } } catch (Exception e) { e.printStackTrace(); } return 0; } 首先使用反射能达到上面的获取一个id的情况，但是比较麻烦，当需要返回一个数组我们就不得不使用这种方法了 private int[] getStyleableArryId(String styleableName){ try { Class&lt;?&gt; loadClass = getContext().getClassLoader().loadClass(getContext().getPackageName() + &quot;.R&quot;); Class&lt;?&gt;[] classes = loadClass.getClasses(); for(int i=0 ;i&lt;classes.length ;i++){ Class&lt;?&gt; resClass = classes[i]; if(resClass.getName().equals(getContext().getPackageName() + &quot;.R$styleable&quot;)){ Field[] fields = resClass.getFields(); for (int j = 0; j &lt; fields.length; j++) { if(fields[j].getName().equals(styleableName)){ int[] styleable = (int[]) fields[j].get(null); return styleable; } } } } } catch (Exception e) { e.printStackTrace(); } return null; } 但是在设置styleable的资源id的时候，如果你是自定义的View，如果需要引入自定义的attr,比如这样：public WheelVerticalView(Context context, final AttributeSet attrs) { this(context, attrs, R.attr.abstractWheelViewStyle); this(context, attrs, 0); } 那么你是不能通过上面的方法，来获取资源文件的，因为这是一个构造器，你只能另找它法了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 微信sdk登录和分享]]></title>
      <url>%2F2017%2F04%2F10%2FweChat-login%2F</url>
      <content type="text"><![CDATA[准备材料： 微信开发者账号 注册你的APP libammsdk.jar包 debug.keystore文件 准备工作 申请你的APPID 导入libammsdk.jar包 在AndroidManifest.xml中设置权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 注册APP到微信 private static final String App_Id = &quot;你注册的APP_ID&quot;; private IWXAPI api; public void registerToWX(){ api = WXAPIFactory.createWXAPI(this, App_Id, true); api.registerApp(App_ID); } 分享： 分享(以分享图片为例) 直接触发分享图片按钮的点击事件 findViewById(R.id.send_img).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.send_img); WXImageObject imgObj = new WXImageObject(bmp); WXMediaMessage msg = new WXMediaMessage(); msg.mediaObject = imgObj; Bitmap thumbBmp = Bitmap.createScaledBitmap(bmp, 150, 150, true); bmp.recycle(); msg.thumbData = Util.bmpToByteArray(thumbBmp, true); SendMessageToWX.Req req = new SendMessageToWX.Req(); req.transaction = buildTransaction(&quot;img&quot;); req.message = msg; req.scene = SendMessageToWX.Req.WXSceneTimeline; SendMessageToWX.Req.WXSceneSession; api.sendReq(req); finish(); } }); 其中req.scene表示分享选择分别代表分享到朋友圈和会话框 Util是一个图片处理的类 登录 登录需要重新APP到微信，需要触发回调,下面直接上代码： package com.lht.pan_android.wxapi; import org.apache.http.Header; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import com.alibaba.fastjson.JSON; import com.lht.pan_android.HttpUtil; import com.lht.pan_android.MainActivity; import com.lht.pan_android.R; import com.lht.pan_android.WeChatCodeBean; import com.loopj.android.http.AsyncHttpResponseHandler; import com.tencent.mm.sdk.modelbase.BaseReq; import com.tencent.mm.sdk.modelbase.BaseResp; import com.tencent.mm.sdk.modelmsg.SendAuth; import com.tencent.mm.sdk.openapi.IWXAPI; import com.tencent.mm.sdk.openapi.IWXAPIEventHandler; import com.tencent.mm.sdk.openapi.WXAPIFactory; public class WXEntryActivity extends Activity implements IWXAPIEventHandler { private static final String TAG = &quot;wechat&quot;; private static final String APP_ID = &quot;你的APP_Id&quot;; private static final String APP_SECRET = &quot;你的APP_secret&quot;; private Button registerBtn; private IWXAPI api; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.entry); registerBtn = (Button) findViewById(R.id.reg_btn); tv = (TextView) findViewById(R.id.log); api = WXAPIFactory.createWXAPI(this, APP_ID, true); registerBtn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { loginWithWeixin(); } }); api.handleIntent(getIntent(), this); } //登录信息 private void loginWithWeixin() { if (api == null) { api = WXAPIFactory.createWXAPI(this, APP_ID, false); } if (!api.isWXAppInstalled()) { Toast.makeText(this, &quot;没有安装微信&quot;, Toast.LENGTH_SHORT).show(); return; } api.registerApp(APP_ID); SendAuth.Req req = new SendAuth.Req(); req.scope = &quot;snsapi_userinfo&quot;; req.state = &quot;com.lht.bridge.session&quot;; api.sendReq(req); } @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this); } //实现了IWXAPIEventHandler @Override public void onReq(BaseReq req) { } //实现了IWXAPIEventHandler @Override public void onResp(BaseResp resp) { code_code = ((SendAuth.Resp) resp).code; String result = null; switch (resp.errCode) { case BaseResp.ErrCode.ERR_OK: result = &quot;发送成功&quot;; //此处进行数据请求，请求用户信息 Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_USER_CANCEL: result = &quot;发送取消&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_AUTH_DENIED: result = &quot;发送被拒绝&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; default: result = &quot;发送返回&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; } Toast.makeText(this, result, Toast.LENGTH_LONG).show(); } } 实现IWXAPIEventHandler接口，微信发送的请求将回调到onReq方法，发送到微信请求的响应结果将回调到onResp方法 在WXEntryActivity中将接收到的intent及实现了IWXAPIEventHandler接口的对象传递给IWXAPI接口的handleIntent方法 在Androidmanifest.xml中注册： &lt;activity android:name = &quot;.wxapi.WXEntryActivity&quot; android:exported = &quot;true&quot;/&gt; 请求用户信息： 微信需要先获取到code，再根据code获取access_token，根据access_token获取openId，最后根据access_token和openId获取用户信息 到此微信登录和分享的流程基本走通了，但是还有许多需要注意的问题 1、最最最重要的一点是登录需要单独写一个包,据说这样登录才能走微信自己的一套机制 格式为：包名.wxapi 类名：WXEntryActivity.java 2、导入的jar包问题，jar包导入的不对就可能导致获取code这一步出现问题，微信的jar包分为老版本和新版本，新版本的可以直接获取access_token，但是官网并没有说明怎么通过access_token获取用户信息，老版本的jar包是可以获取code的，然后自己根据code自己写网络请求(你没有看错，就是自己写网络请求)； 3、程序运行时一定要保证你的签名正确，如果需要更换你的key，windows下需要更换sdk/.android/debug.keystore以正确替换你的key 目前能想到的就这些了，有什么问题欢迎指出，最后吐槽一下微信登录竟然收费、微信的文档就呵呵了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native探索与设计(一)]]></title>
      <url>%2F2017%2F04%2F09%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[React Native探索与设计(一) 1. React Native有什么优点 跨平台 动态更新 代码复用 最大的优势就是既有Web的热更新优势，又有接近Native的性能 2. React Native VS Hybrid 性能： Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少。 用户体验：React Native 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。 3. React Native VS Weex Weex bug比较多 社区、文档弱，GitHub Issue 基本是中文:这就意味着Weex并没有国际化，Weex还有很长的路要走 4. React Native 劣势 学习成本：而 React Native 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大(ES6的箭头函数、展开运算符) 首次加载耗时：React Native 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新(在发布 client 时内置一个写好的 js 文件在本地作缓存用) 5. React Native 运行机制 在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件 读取 JavaScript 源码。JavaScript 加载进内存, JSX 代码已经被转化成原生的 JavaScript 代码 初始化模块信息。通过initModulesWithDispatchGroup()找到所有需要暴露给JavaScript的类 初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象 生成模块列表并写入 JavaScript 端 执行 JavaScript 源码 React Native运行机制详解 6. React Native 开发环境搭建 IDE：Nuclide、Deco、Webstorm、Sublime Text 环境搭建 一、安装Homebrew。Homebrew是Mac OSX的包管理器，我们需要通过Homebrew安装开发React Native的相关软件包。 二、安装Node.js。 $brew install node 三、安装watchman。watchman是Facebook用于监视JavaScript文件改动的开源项目。 $brew install watchman 四、安装flow。flow是Facebook开源的一个JavaScript静态类型检查器，用于发现JavaScript程序中的类型错误。 $brew install flow 五、安装react-native-cli。react-native-cli是React Native的命令行工具，安装react-native-cli后我们就能够通过react-native相关命令管理ReactNative工程。 $npm install -g react-native-cli 目录结构 android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行 node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成； js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自动生效。]]></content>
    </entry>

    
  
  
</search>
