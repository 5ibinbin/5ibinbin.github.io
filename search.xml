<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2018%2F01%2F09%2FAlgorithm%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[序言：本文将带你掌握二叉树、二叉搜索树以及他们的构建、元素的查找和删除 二叉树 满足树中的节点最多只能有两个的就称为二叉树 二叉搜索树(BTS) 在满足二叉树的基础上且满足左侧节点的值比父节点小，右侧节点的值比左侧节点大的称为二叉搜索树。 二叉树特性 由于这种树形的数据结构使得其无论是增删还是查找，算法的时间复杂度都为O(h)，h为数的高度。因此二叉树应尽可能的使左右平衡。 二叉搜索树的构建 12345678function BinarySearchTree() &#123; let Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; let root = null;&#125; 创建BinarySearchTree类，声明每一个节点的数据结构，并将初始的根节点置为null(行7) 二叉搜索树的插入(insert) 12345678this.insert = function(key)&#123; let newNode = new Node(key); if (root === null)&#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125;&#125; ① 创建Node实例来生成一个新的节点行2② 判断根节点是否为null，若是则新建节点为根节点，否则插入节点 123456789101112131415161718192021222324252627282930313233let insertNode = function(node, newNode)&#123; if (newNode.key &lt; node.key)&#123; if (node.left === null)&#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null)&#123; node.right = newNode &#125; else &#123; insertNode(node.right, newNode); &#125; &#125;&#125;``` &gt; 树非空情况下，先判断新节点是否小于当前节点(局部根节点)，若小于需要判断当前节点的左节点是否为空，若为空则将当前节点的左节点赋值为新节点，否则继续递归调用`insertNode`方法。若新节点大于当前节点的情况和小于的类似。 **搜索最大值最小值**&gt; 我们知道二叉搜索树的左节点小于根节点小于右节点，我们可以根据这个特性来求得最大值最小值，方法如下：```javascriptthis.minNode = function()&#123; if (root)&#123; while(root &amp;&amp; root.left !== null)&#123; root = root.left; &#125; return root.key; &#125; return null;&#125; 1234567891011121314151617181920212223242526this.maxNode = function()&#123; if (root)&#123; while(root &amp;&amp; root.right !== null)&#123; root = root.right; &#125; return root.key; &#125; return null;&#125;``` **查找特定的值**```javascriptthis.search = function(root, key)&#123; if (root === null)&#123; return false; &#125; if (key &lt; root.key)&#123; return search(root.left, key); &#125; else if (key &gt; root.key)&#123; return search(root.right, key); &#125; else if ()&#123; return true; &#125;&#125; 依然使用了递归的思想。如果目标值比当前节点小则继续在左侧子树上搜索，比当前节点大则在右侧子树搜索直到找到目标值。 删除节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344this.remove = function(key)&#123; root = removeNode(root, key);&#125;let removeNode = function(node, key)&#123; if (node === null)&#123; return null; &#125; if (key &lt; node.key)&#123; node.left = removeNode(node.left, key); return node; &#125; else if (key &gt; node.key)&#123; node.right = removeNode(node.right, key); return node; &#125; else &#123; // 第一种情况--一个叶子节点 if (node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; // 第二种情况--一个只有一个子节点的节点 if (node.left === null)&#123; node = node.right; return node; &#125; else if (node.right === null)&#123; node = node.left; return node; &#125; // 第三种情况--一个有两个子节点的节点 let minNode = findMinNode(node.right); node.key = minNode.key; node.right = removeNode(node.right, minNode); return node; &#125;&#125;let findMinNode = function(node)&#123; if (node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node; &#125;&#125; 要想移除节点，首先需要找到节点node.key === key，移除节点分三种情况：① 只有一个叶子节点，我们只需要把节点置空就可以了② 只有一个子节点的节点，需要把它的子节点覆盖当前节点③ 有两个子节点，首先调用findMinNode找到当前节点的右子节点内的最小节点，然后将这个最小节点赋值给当前节点(把要删除的节点给覆盖删除)，最后再把之前找到的最小节点从原来的位置删除。 关于第三种情况看一看下图以加深理解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序查找和二分查找]]></title>
    <url>%2F2018%2F01%2F08%2FAlgorithm%2F%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[顺序查找 说明：顺序查找适用于数据存储形式为顺序存储或链接存储的线性表 算法思想 顺序查找也是线性查找，从数据的一端开始依次查找每一条数据元素并与目标值进行比较。如果相等则找到目标值，否则继续向下查找。 复杂度分析 算法平均执行次数为n/2，则算法的复杂度为O(n) 代码实现 12345678function sequenceSearch(arr, targetValue)&#123; for (let i = 0; i &lt; arr.length; i++)&#123; if (arr[i] === targetValue)&#123; return i; &#125; &#125; return -1;&#125; 二分查找 说明：二分查找适用于已排序的数据 算法思想 二分查找也成为折半查找，将目标值与已排序数据中间值比较，若等于中间值则查找成功；若小于/大于中间值则对左/右侧数据再进行二分查找，依次类推，直到找到目标值。 复杂度分析 最坏情况需要执行log(n+1)，则算法的复杂度为O(logn) 代码实现 1234567891011121314151617function BinarySearch(arr, targetValue)&#123; let low = 0; let high = arr.length - 1; while(low &lt; high)&#123; let middle = Math.floor((low+high)/2); if (arr[middle] &lt; targetValue)&#123; low = middle + 1; &#125; if (arr[middle] === targetValue)&#123; return middle; &#125; if (arr[middle] &gt; targetValue)&#123; high = middle - 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F01%2F07%2FAlgorithm%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 和归并排序一样，快速排序也采用分治的思想 ① 先从数组中取出一个数作为基准数② 分区过程 – 将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边③ 再对左右区间重复第二步，直到各区间只有一个数 复杂度 快排的平均时间复杂度为O(nlogn)，空间复杂度为O(logn)，快速排序是不稳定的，但每次都能确定一个元素所在序列中的最终位置，复杂度与初始序列(基准值)有关 代码实现 12345678function quickSort(arr, indexLeft, indexRight)&#123; if (indexLeft &gt;= indexRight)&#123; return; &#125; let index = position(arr, indexLeft, indexRight); quickSort(arr, indexLeft, index - 1); quickSort(arr, index + 1, indexRight);&#125; ① 第2行为递归的终止条件② 可能有人对第6、7行有疑问，为什么递归的时候少了index，因为index就数组的基准值 1234567891011121314151617function position (arr, indexLeft, indexRight)&#123; let key = arr[indexLeft]; let low = indexLeft; let high = indexRight; while (low &lt; high)&#123; while (arr[high] &gt; key)&#123; high--; &#125; arr[low] = arr[high]; while (arr[low] &lt; key)&#123; low++; &#125; arr[high] = arr[low]; &#125; arr[low] = key; return low;&#125; ① 第5行判断数组长度大于1② 第6~9行从数组末端开始和基准值key比较，如果大于key则往前移，否则和第low个值交换③ 第10~13从数组头部开始和基准值key比较，如果小于key则往后移，否则和第high个值交换直到low不小于high，while循环结束，此时将基准值赋予角标为low处。 可以看下面的例子，增加以下理解 5 5 4 8 3 2 6 7 9 首先用5当作基准，使用i j两个指针分别从两边进行扫描，首先比较9和5，9比5大，j左移。继续比较，7&gt;5, 6&gt;5, j左移两次，接着比较2和5，2&lt;5,交换 5 2 4 8 3 _ 6 7 9 将2移至i原来所在的位置，同时把2原来所在的位置空出来(相当于空出来，其实2还留在原地)，并开始从左侧比较。4和5比较 5 2 4 8 3 _ 6 7 9 4&lt;5，不交换，i继续右移 5 2 4 _ 3 8 6 7 9 8&gt;5，将8与j所在的位置交换，j左移，将3与5比较 5 2 4 3 _ 8 6 7 9 3&lt;5，3移至i所在的位置，i继续右移，此时i=j，循环结束。 5 2 4 3 5 8 6 7 9 循环结束将基准值5移至空位。此时一轮排序到此结束，之后将以同样的方式继续比较，直到数据排列完成]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F01%2F06%2FAlgorithm%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 该算法是一种分治算法，其思想是将原始数据分割为较小的数据，直到每个数组只有一个元素，然后再将小数组归并为一个数组。 性能 时间复杂度总是为O(NlogN)，空间复杂度也总为为O(N)，算法与初始序列无关，排序是稳定的。 代码实现 123456789101112131415161718192021222324252627282930313233343536function mergeSort(arr)&#123; let length = arr.length; if (length === 1)&#123; //递归终止条件 return; &#125; let middle = Math.floor(length/2); let arrayLeft = arr.slice(0, middle); let arrayRight = arr.slice(middle+1, length-1); merge(mergeSort(arrayLeft), mergeSort(arrayRight));&#125;function merge(arrayLeft, arrayRight)&#123; //数组合并和排序 let result = []; let indexLeft = 0; let indexRight = 0; while(indexLeft &lt; arrayLeft.length &amp;&amp; indexRight &lt; arrayRight.length)&#123; //谁小就将它放到数组里面 if (arrayLeft[indexLeft] &lt; arrayRight[indexRight])&#123; result.push(arrayLeft[indexLeft]); indexLeft++; &#125; else &#123; result.push(arrayRight[indexRight]); indexRight++; &#125; &#125; while(indexLeft &lt; arrayLeft.length)&#123; //将剩余的放到数组 result.push(arrayLeft[indexLeft]); indexLeft++; &#125; while(indexRight &lt; arrayRight.length)&#123; //将剩余的放到数组 result.push(arrayRight[indexRight]); indexRight++; &#125; return result; &#125; ① 注意递归终止条件(所有递归都必须注意的点)② 大数组通过mergeSort()分割为单位为1的小数组，直到递归终止③ 通过merge()将一个个单位为1的数组合并为大数组，合并的过程就是排序的过程]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2018%2F01%2F05%2FAlgorithm%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 依次选择一个待排序的数据，插入到前边已排好序的序列中。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，比较次数与初始序列有关。 代码实现 123456789101112function insertSort(arr)&#123; let length = arr.length; for (let i = 1; i &lt; length - 1; i++)&#123; for (let j = i; j &gt; 0; j--)&#123; if (arr[j] &lt; arr[i])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; else &#123; break; &#125; &#125; &#125;&#125; 外层循环从数组的第二项开始遍历，内层循环从后往前遍历，如果小于外层数值，则插入(交换)当前位置 优化 123456789101112131415161718function insertSort(arr)&#123; let length = arr.length; let temp = 0; let index = 0; for (let i = 1; i &lt; length; i++)&#123; temp = arr[i]; index = i; for (let j = i; j &gt; 0; j--)&#123; if (temp &lt; arr[j-1])&#123; arr[j] = arr[j-1]; index = j - 1; &#125; else &#123; break; &#125; &#125; arr[index] = temp; &#125;&#125; 外层循环从数组的第二项开始遍历，内层循环从后往前遍历，如果小于外层数值，则将当前值往后移(10行)，并将当前值的角标记录下来(11行)，最后我们将temp赋给空出来的那个位置。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F01%2F04%2FAlgorithm%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 找到数据结构中的最小值，并记录其角标，将其放到第一位，接着找到第二小的值并把它放到第二位，以此类推。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是不稳定的，每次都能确定一个元素所在的最终位置，比较次数与初始序列无关。 代码实现 1234567891011121314function selectionSort(arr)&#123; let length = arr.length; for (let i = 0; i &lt; length - 1; i++)&#123; let min = i; for (let j = i; j &lt; length; j++)&#123; if (arr[min] &gt; arr[j])&#123; min = j; &#125; &#125; if (i !== min)&#123; [arr[i], arr[min]] = [arr[min], arr[i]]; &#125; &#125;&#125; 额外维护一个变量min来记录最小数据元素对应的角标。内层循环通过比对来寻找最小元素的角标，外层循环负责在min变动的时候对数据元素进行交换。 选择排序与冒泡排序 冒泡排序每次发现有更小元素就立即交换到序列首位，而选择排序发现有更小元素时，只是记录其下标，等到内层循环完之后，在将最小元素交换到首位]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F01%2F03%2FAlgorithm%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 相邻的数据进行两两比较，较大的数放到后面，这样每次都能找到一个最大的数，循环执行n次就能把全部数据按顺序排列。冒泡有两种形式，一种是把小的冒泡到前边去，另一种是把大的元素冒泡到后边。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。 代码实现 ①将大的数据元素放到后面 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = 0; j&lt; arr.length - 1; j++)&#123; if (arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] //es6语法 &#125; &#125; &#125;&#125; ②将小的数据元素放到前面 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = i + 1; j&lt; arr.length; j++)&#123; if (arr[i] &gt; arr[j])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] //es6语法 &#125; &#125; &#125;&#125; 内层循环过程中，两两比较，将较大/小的数据元素交换到下一位置，外层循环每完成一次，当前序列的最大/小的元素就会冒到当前序列的尾位置 优化 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = 0; j&lt; arr.length - 1 - i; j++)&#123; // this line if (arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] //es6语法 &#125; &#125; &#125;&#125; 外层循环每执行一次，最前或最后的元素都是最大或最小的，所以我们内层循环时可去掉已排好序的数据。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs scope(作用域)]]></title>
    <url>%2F2017%2F12%2F07%2FAngularJs%2FAngularJs%20%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[$rootScope每个AngularJs应用默认有一个根作用域–$rootScope， 根作用域位于最顶层，作为其他作用域的父作用域，可作用于整个应用中。$scope scope(作用域)对应MVC模式的Model，是应用在HTML(视图)和JavaScript(控制器)之间的纽带，可应用在视图和控制器上。 scope是表达式执行的上下文，同时作用域也是一个对象，有可用的方法和属性。 一、变量的取值和赋值1234567891011121314&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;button ng-click="number = number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; function parentCtrl($scope)&#123; $scope.number = 1;&#125;function childCtrl($scope)&#123; &#125; 效果： 界面上显示了两个1，但当我们点击按钮之后，childCtrl作用域内的数据改变了，parentCtrl作用域内的数据没有改变 分析： ①childCtrl作用域继承了parentCtrl作用域(类似于JavaScript的原型链继承)，所以childCtrl作用域可以访问到parentCtrl的内容。 ②点击按钮后childCtrl作用域就会创建一个number基础类型变量，当childCtrl已有某个基础类型变量就不会访问原型链。 解决： ①可以使用$parent来指定上级作用域改变 1234567&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;button ng-click="$parent.number = number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ②使用引用类型变量，内外层作用域均是data对象的引用，修改对象的属性，引用的还是同一个变量。 1234567891011121314&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;data.number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;data.number&#125;&#125;&lt;/span&gt; &lt;button ng-click="data.number = data.number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; function parentCtrl($scope)&#123; $scope.data.number = 123';&#125;function childCtrl($scope)&#123; &#125; ng-if、ng-repeat、ng-switch、ng-include等指令也会产生新作用域 二、Directive中的作用域1234567891011121314151617.directive("myDirective", function () return &#123; restrict: "AE", scope: &#123; name: '@myName', age: '=', changeAge: '&amp;changeMyAge' &#125;, replace: true, template: "&lt;div class='my-directive'&gt;" + "名字：&lt;span ng-bind='name'&gt;&lt;/span&gt;&lt;br/&gt;" + "年龄：&lt;span ng-bind='age'&gt;&lt;/span&gt;&lt;br/&gt;" + "修改名字：&lt;input type='text' ng-model='name'&gt;&lt;br/&gt;" + "&lt;button ng-click='changeAge()'&gt;修改年龄&lt;/button&gt;" + " &lt;/div&gt;" &#125;&#125; ①scope：false 当scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。 ②scope：true 当scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承的父作用域；可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。 ③scope：{}@ 这是一个单项绑定的前缀标识符 &lt;div my-directive my-name=&quot;&quot;&gt;&lt;/div&gt; 属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过&#123;&#123; &#125;&#125;使用来绑定数据。 = 这是一个双向数据绑定前缀标识符 &lt;div my-directive age=&quot;age&quot;&gt;&lt;/div&gt; 数据的双向绑定要通过=前缀标识符实现，所以不可以使用。 &amp; 这是一个绑定函数方法的前缀标识符 &lt;div my-directive change-my-age=&quot;changeAge()&quot;&gt;&lt;/div&gt; 属性的名字要用-将多个个单词连接。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 问题总结]]></title>
    <url>%2F2017%2F12%2F01%2FAngularJs%2FAngularJs%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AngularJs 问题总结 一、ng-if/ng-show 最根本的区别是页面是否会生成此DOM元素 二、ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？ 会提示 Duplicates in a repeater are not allowed.，数据与DOM之间一对一的关系在数据相同的情况下不成立。通过 track by key key 为数组的唯一标识，目的是建立数组与DOM的关联。 三、ionic ion-slide-box bugion-slide-box在数量为两个的情况下会造成 ion-slide的数量由2个变成4个①修改slideChanged方法 12345678$scope.slideChanged = function(index) &#123; $scope.slideIndex = index; if ( ($ionicSlideBoxDelegate.count() -1 ) == index ) &#123; $timeout(function()&#123; $ionicSlideBoxDelegate.slide(0); &#125;,3000); &#125; &#125;; 在数据为2的时候手动调用 $ionicSlideBoxDelegate.slide(0) 跳转到第一个 ②修改源码 $scope.numSlides = function() { if (!slideBox._length){ slideBox._length = slideBox.slidesCount() || 0; } return new Array(slideBox._length); }; $scope.$watch('currentSlide', function(v) { selectPage(v%(slideBox.slidesCount()||0)); }); 在 ionic.bundle.js 的第63314行附近，修改以上两个方法。执行slideBox个数的取余操作 四、在Html页面调取JS原生方法(parseInt)失效？ 在页面中，都不能直接调用原生的JS 方法，因为这些并不存在于与页面对应的Controller 的$scope 中 更新中。。。。。。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git The Requested URL return error 403]]></title>
    <url>%2F2017%2F11%2F29%2FGit%2FGit%20The%20Requested%20URL%20return%20error%20403%2F</url>
    <content type="text"><![CDATA[一、 问题描述git在 pull/push 代码的时候提示：The Requested URL return error 403，这表示我们没有权限来pull/push相关代码 二、 问题分析 有可能你是真的没有权限(认真脸) 你修改了git仓库的用户名和密码，导致你内存和硬盘中缓存的账号密码不能使用 三、问题处理1、执行git config --list，查看git的配置信息 图中红色部分内容[user] 为你的git账号配置信息，[credential]为你的这些信息存储位置 2、执行vim .git-credentials，查看credential中缓存的账户 2、 执行git help -a | grep credential，查看git的信息存储位置 git help -a | grep credential命令查看自己系统支持的crendential, cache 代表内存中的缓存，store 代表磁盘。git config credential.helper命令可以看到 cache、store、osxkeychain(钥匙串)中是否还有git的配置信息。由图中我们可以得出git config还存储在store中 3、一般配置方法： git config --global (--replace-all) user.name &quot;你的用户名&quot; git config --global (--replace-all) user.email &quot;你的邮箱&quot; 4、如果上述步骤没有效果，我们就需要清除缓存(.gitconfig) git config --local --unset credential.helper git config --global --unset credential.helper git config --system --unset credential.helper 具体介绍可以查看这里, 可能有多处.gitconfig文件 四、 重复输入用户名密码清除缓存之后我们每次提交代码的时候都需要输入用户名和密码 git config --global credential.helper store 或者 执行修改.gitconfig配置文件，把以下内容放置到最后 [credential] helper = store 执行 vim .gitconfig查看 本次问题到此结束，如有问题请留言 友情链接关于credential的介绍可以点击这里关于.gitconfig清除缓存可以点击这里]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova 保存图片到本地]]></title>
    <url>%2F2017%2F11%2F15%2FAngularJs%2FCordova%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[我们将介绍两种方式将照片保存到本地 官方下载插件FileTransfer 这种方式会有一个弊端就是图片在相册里面找不到需要刷新一下系统目录或者重启一下手机才能在相册里面查看到图片但是可以下载动图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051vm.url = encodeURI(baseConfig.imgPath + vm.nowImgs[vm.nowImgIndex]);vm.fileName = vm.nowImgs[vm.nowImgIndex].split("/").pop();var fileTransfer = new FileTransfer();var trustHosts = true;var options = &#123; headers: &#123; "Authorization": 'access_token' &#125; &#125;;//Android：vm.fileURL = cordova.file.externalRootDirectory;window.resolveLocalFileSystemURL(vm.fileURL, function (fileEntry) &#123; fileEntry.getDirectory("Giti", &#123;create: true, exclusive: false&#125;, function (fileEntry) &#123; fileEntry.getDirectory("img", &#123;create: true, exclusive: false&#125;, function (fileEntry) &#123; fileTransfer.download( vm.url, fileEntry.toURL() + vm.fileName, function (success) &#123; &#125;, function (error) &#123; &#125;, options, trustHosts ); &#125;, function () &#123; publicMethod.showLoadingNoBackdrop('img文件夹创建失败'); &#125;); &#125;, function () &#123; publicMethod.showLoadingNoBackdrop('Giti文件夹创建失败'); &#125;);&#125;);// iOSvm.fileURL = cordova.file.documentsDirectory + vm.fileName;window.requestFileSystem(LocalFileSystem.PERSISTENT, 5 * 1024 * 1024, function (fs) &#123; fs.root.getDirectory('Giti', &#123;create: true, exclusive: false&#125;, function (directory) &#123; fileTransfer.download( vm.url, directory.nativeURL + vm.fileName, function (success) &#123; &#125;, function (error) &#123; &#125;, trustHosts, options ); &#125;);&#125;); Canvas2ImagePlugin插件 这种方法可以直接在相册里面看到图片但是动图看不到，下面是参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445function keepImg()&#123; var success = function (msg) &#123; &#125;; var error = function (err) &#123; &#125;; saveImageToPhone(vm.url, success, error);&#125; function saveImageToPhone(url, success, error) &#123; var canvas, context, imageDataUrl, imageData; var img = new Image(); img.src = url; img.onload = function () &#123; console.log('Img size: ' + img.naturalWidth + 'x' + img.naturalHeight); canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; context = canvas.getContext('2d'); context.drawImage(img, 0, 0); try &#123; imageDataUrl = canvas.toDataURL('image/jpeg', 1.0); imageData = imageDataUrl.replace(/data:image\/jpeg;base64,/, ''); cordova.exec( success, error, 'Canvas2ImagePlugin', 'saveImageDataToLibrary', [imageData] ); &#125; catch (e) &#123; error(e.message); &#125; &#125;; try &#123; img.src = url; console.log("153" + img.src); &#125; catch (e) &#123; console.log("156" + img.src); error(e.message); &#125;&#125;]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 介绍]]></title>
    <url>%2F2017%2F09%2F02%2FGulp%2FGulp%2F</url>
    <content type="text"><![CDATA[gulp: 是一个自动化构建工具, 开发者可以使用它在项目开发过程中自动执行常见任务, 是基于node.js构建的。借鉴了Unix操作系统的管道(pipe)思想。 1、 gulp.src(globs[, options]) globs:需要处理的源文件匹配符路径 类型：String 或者 StringArray 通配符路径匹配示例： “src/a.js”：指定具体文件； “*”：匹配所有文件 例：src/*.js(包含src下的所有js文件)； “**”：匹配0个或多个子文件夹 例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)； “{}”：匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)； “!”：排除文件 例：!src/a.js(不包含src下的a.js文件)； options 类型(可选)：Object 有3个属性buffer、read、base options.buffer： 类型：Boolean 默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用； options.read： 类型：Boolean 默认：true 设置false，将不执行读取文件操作，返回null； options.base： 类型：String 设置输出路径以某个路径的某个组成部分为基础向后拼接 123456var scssPath = ["app/css/*.scss","app/css/**/*.scss"];gulp.task('sass', function () &#123; return gulp.src('app/theme/*.scss') //该任务针对的文件 .pipe(sass()) //该任务调用的模块 .pipe(gulp.dest('www/build/css')); // 文件输出路径&#125;); 2、gulp.dest(path[, options]): 指定文件输出路径 path 类型(必填)：文件输出路径 options 类型(可选)：Object 有2个属性cwd、mode options.cwd(String): process.cwd()：前脚本的输出路径，当文件输出路径为相对路径将会用到 options.mode: 被创建文件夹的权限 gulp.dest()一般与gulp.src()一起使用 3、gulp.task(name[, deps], fn)：执行一个task任务 name: 类型(必填) String 指定的任务名(不应该有空格) deps: 类型(选填) StringArray 该任务所依赖的任务(依赖的任务先于该任务执行) fn: 回调函数 1234567891011gulp.task('testLess', function () &#123; return gulp.src(['less/style.less']) .pipe(less()) .pipe(gulp.dest('./css'));&#125;); gulp.task('minicss', ['testLess'], function () &#123; //执行完testLess任务后再执行minicss任务 gulp.src(['css/*.css']) .pipe(minifyCss()) .pipe(gulp.dest('./dist/css'));&#125;); 4、gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb])：watch方法是用于监听文件变化，文件一修改就会执行指定的任务 glob: 需要处理的源文件匹配符路径 opts: Object 传给 gaze(实际监听者) 的参数 task(必填): StringArray 需要执行的任务 cb(可选): function 每个文件变化执行的回调函数 123gulp.task('watch', function () &#123; gulp.watch(['app/**/*'], ["build-dev"]);&#125;); Gulp 插件集]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 双向绑定原理(数据绑定机制)]]></title>
    <url>%2F2017%2F08%2F26%2FAngularJs%2FAngularJs%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86(%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6)%2F</url>
    <content type="text"><![CDATA[AngularJs 为 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view(html) 上时 AngularJs 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发。$digest 会遍历所有的 $watch。从而更新DOM。 $watch这有点类似于我们的观察者模式，在当前作用域$scope下，我们创建一个监控器$watchers和一个监听器$watch，$watchers 负责管理所有的 $watch，当我们每次绑定到UI上的时候就自动创建一个$watch，并把它放到 $watchers。 controller.js 1234app.controller('MainCtrl', function($scope) &#123; $scope.Hello = "Hello"; $scope.world = "World";&#125;); index.html 1&lt;div&gt;&#123;&#123;Hello&#125;&#125;&lt;/div&gt; 这里，即便我们在$scope上添加了两个变量，但是只有一个绑定在了UI上，因此在这里只生成了一个$watch $digest当浏览器接收到可以被angular context处理的事件时，$digest循环就会触发。$digest将会遍历我们的$watch，如果$watch没有变化，这个循环检测就将停止，如果有至少一个更新过，这个循环就会再次触发，直到所有的$watch都没有变化。这样就能够保证每个model都已经不会再变化。这就是脏检查(Dirty Checking)机制controller.js 1234567app.controller('MainCtrl', function() &#123; $scope.name = "Foo"; $scope.changeFoo = function() &#123; $scope.name = "Bar"; &#125;&#125;); index.js 12&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;button ng-click="changeFoo()"&gt;Change the name&lt;/button&gt; 当我们按下按钮 浏览器接收到一个事件，进入angular context。 $digest循环开始执行，查询每个$watch是否变化。 由于监视$scope.name的$watch报告了变化，它会强制再执行一次$digest循环。 新的$digest循环没有检测到变化。 更新与$scope.name新值相应部分的DOM。 $apply$apply 我们可以直接理解为刷新UI。如果当事件触发时，你调用$apply，它会进入angular context，如果没有调用就不会进入，之后的$digest检测机制就不会触发123456789101112131415app.directive('clickable', function() &#123; return &#123; restrict: "E", scope: &#123; foo: '=' &#125;, template: '&lt;ul style="background-color: lightblue"&gt;&lt;li&gt;&#123;&#123;foo&#125;&#125;&lt;/li&gt;&lt;/ul&gt;', link: function(scope, element, attrs) &#123; element.bind('click', function() &#123; scope.foo++; console.log(scope.foo); &#125;); &#125; &#125;&#125;); 当我们调用clickable指令的时候，我们可以看到foo的值增加了，但是界面上显示的内容并没有改变。$digest脏检测机制没有触发，检测foo的$watch就没有执行。 $apply()方法的两种形式1) 无参1$scope.$apply(); 使用12345element.bind('click', function() &#123; scope.foo++; //if error scope.$apply();&#125;); 当我们使用这种形式的时候，如果在scope.$apply之前程序发生异常，那scope.$apply没有执行，界面就不会更新 2) 有参123$scope.$apply(function()&#123; ...&#125;) 使用12345element.bind('click', function() &#123; scope.$apply(function() &#123; scope.foo++; &#125;);&#125;) 如果用这种形式，即使后面的发生异常，数据还是会更新。 在 AngularJS 中使用 $watch常用的使用方式： 12345$scope.name = 'Hello';$scope.$watch('name', function(newValue, oldValue) &#123; if (newValue === oldValue) &#123; return; &#125; $scope.updated++;&#125;); 传入到$watch()中的第二个参数是一个回调函数，该函数在name的值发生变化的时候会被调用。 如果要监听的是一个对象，那还需要第三个参数： 12345$scope.data.name = 'Hello';$scope.$watch('data', function(newValue, oldValue) &#123; if (newValue === oldValue) &#123; return; &#125; $scope.updated++;&#125;, true); 表示比较的是对象的值而不是引用，如果不加第三个参数true，在 data.name 变化时，不会触发相应操作，因为引用的是同一引用。 总结1) 只有在$scope变量绑定到页面上，才会创建 $watch2) $apply决定事件是否可以进入angular context3) $digest 循环检查model时最少两次，最多10次(多于10次抛出异常，防止无限检查)4) AngularJs自带的指令已经实现了$apply，所以不需要我们额外的编写5) 在自定义指令时，建议使用带function参数的$apply]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
        <tag>数据双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 流式布局]]></title>
    <url>%2F2017%2F08%2F22%2FAngularJs%2FAngularJs%20%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[移动端实现图片高度不固定的照片墙效果 流式布局照片墙一、 HTML123&lt;div class='box' ng-repeat="img in imgs track by $index" on-finish-render-filters&gt; &lt;img class='item' ng-src='&#123;&#123;img&#125;&#125;'&gt;&lt;/div&gt; 二、JS 获取所有布局元素12345678910function getAllChild(parent, className) &#123; vm.childName = parent.getElementsByTagName("*"); vm.tempArray = []; for (var i in vm.childName) &#123; if (vm.childName[i].className === className) &#123; vm.tempArray.push(vm.childName[i]); &#125; &#125; return vm.tempArray; &#125; 获取类选择器中class=&#39;box&#39;中的所有class=‘item’的元素，并放到数组； 获取每列中高度的最小值所对应的列号 123456789101112131415161718192021222324252627282930313233343536function getMinIndex(onlyOneColsArr, minHeight) &#123; for (var i in onlyOneColsArr) &#123; if (onlyOneColsArr[i] === minHeight) &#123; return i; &#125; &#125;&#125; ``` - 重新排列子元素的位置```javascript/* * 排列子元素的位置，并获取每列的高度 * @param &#123;Array&#125; childArr 子元素 * @param &#123;Number&#125; num 列数 * */function getMinHeightOfCols(childArr, num) &#123; for (var i = 0; i &lt; childArr.length; i++) &#123; if (i &lt; num) &#123; //获取每列的高度 vm.colsHeightArray[i] = childArr[i].offsetHeight; &#125; else &#123; // 获取每列中高度的最小值 var minHeightOfCols = Math.min.apply(null, vm.colsHeightArray); // 获取列高度最小值所对应的index var minHeightOfIndex = getMinIndex(vm.colsHeightArray, minHeightOfCols); // 设置子元素的位置 childArr[i].style.position = "absolute"; childArr[i].style.top = minHeightOfCols + 'px'; childArr[i].style.left = childArr[minHeightOfIndex].offsetLeft + "px"; //重置高度最小的列的高度 vm.colsHeightArray[minHeightOfIndex] += childArr[i].offsetHeight; &#125; &#125;&#125; 方法主体 123456789101112131415function photoWall(parent, child) &#123; /* * 获取class为parent的元素 * */ vm.parent = document.getElementsByClassName(parent); //获取class为child的div var childArray = vm.getAllChild(vm.parent, child); vm.getMinHeightOfCols(childArray, 2);&#125;``` - 方法调用```javascriptvm.photoWall('box', 'item'); 以上就是我们页面重新布局的所有代码，细心的小伙伴可能已经发现html上面多了on-finish-render-filters，这个是干什么用的呢，请看下文 三、自定义指令 定义指令 12345678910111213angular.module('onFinishRenderFilterModule', []) .directive('onFinishRenderFilters', function ($timeout) &#123; return &#123; restrict: 'A', link: function (scope, element, attr) &#123; if (scope.$last === true) &#123; $timeout(function () &#123; scope.$emit('ngRepeatFinished'); &#125;, 200); &#125; &#125; &#125;; &#125;); 调用 12345$scope.$on('ngRepeatFinished', function (ngRepeatFinishedEvent) &#123; $timeout(function () &#123; vm.photoWall('box', 'item'); &#125;, 200);&#125;); 指令类型：属性(restrict:’A’), 在界面渲染时调用on-finish-render-filters 属性，然后再通过 $emit 向 controller 发送广播，最后再使用 $on 来接收广播，绘制流式布局。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs之factory、service、provider]]></title>
    <url>%2F2017%2F08%2F16%2FAngularJs%2FAngularJs%E4%B8%ADfactory%E3%80%81service%E3%80%81provider%2F</url>
    <content type="text"><![CDATA[factory、service、provider 我们先通过一段代码来认识一下factory、service、provider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var myApp = angular.module('myApp', []);/* * Factory */myApp.factory('Factory', function() &#123; return &#123; sayHello: function() &#123; return "Hello, 张先生"; &#125; &#125;;&#125;);/* * Service */myApp.service('Service', function() &#123; this.sayHello = function() &#123; return "Hello, 张先生"; &#125;;&#125;);/* * Provider */ myApp.provider('Provider', function() &#123; this.name = '先生'; this.$get = function() &#123; var name = this.name; return &#123; sayHello: function() &#123; return "Hello, " + name; &#125; &#125; &#125;; this.setName = function(name) &#123; this.name = name; &#125;;&#125;);/* * config provider */ myApp.config(function(myProvider)&#123; myProvider.setName('张先生');&#125;);/* * 方法调用 */function MyCtrl($scope, Provider, Factory, Service) &#123; $scope.hellos = [ Provider.sayHello(), Factory.sayHello(), Service.sayHello()];&#125; factory: factory是以个可注入的function。当使用factory来创建服务的时候，相当于新创建了一个对象，然后在这个对象上新添属性，最后返回这个对象。service: service是一个可注入的构造函数。service是单例模式的。当使用service创建服务的时候，相当于使用new关键词进行了实例化。因此，你只需要在this上添加属性和方法，服务就会自动的返回this。provider是一个可配置的factory。provider是唯一一种可以创建用来注入到config()函数的服务的方式。$get 中返回的，就是用 factory 创建 service 的内容. 想在你的服务启动之前，进行一些模块化的配置的话，就使用provider。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 输入框自动变化高度]]></title>
    <url>%2F2017%2F08%2F14%2FAngularJs%2FAngularJs%20%E8%BE%93%E5%85%A5%E6%A1%86%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[AngularJs 输入框自动变化高度 当你想实现一个高度自增长的文本框的时候，也许你首先想到的是textarea，但是使用它太麻烦而且还会有很多问题，下面我们来介绍一种简单有效的方式。 div div中有个属性contenteditable，当把它设为true的时候，这个div就会变为可编辑状态，所以我们可以利用这个属性来使div变为文本域，下面看代码 html 1&lt;div contenteditable="true" id="article-comment-content" class="article-comment-content" onblur="contentBlur()" ng-model="vm.articleComment.content"&gt;&lt;/div&gt; css 1234567891011121314.article-comment-content&#123; padding: 10px; line-height: 20px; font-size: 14px; background: white; -webkit-user-select: text;&#125;.article-comment-content:empty:before &#123; content: '请输入回帖内容'; color: #999;&#125;.article-comment-content:focus:before &#123; content: none;&#125; 以上我们实现了文本输入框并自动增加文本框的高度，并设置了文本框的placeholder。但是细心的你可能要问了，应该怎么实现数据绑定呢？下面我们接着来看这个问题： 其实我们可以通过 var content = $(‘#article-comment-content’).eq(0)[0].textContent 来获取输入框的值，但是这样是不能进行双向数据绑定的。对于这个问题我们可以使用自定义指令的方式123456789101112131415.directive('contenteditable', function () &#123; return &#123; require: 'ngModel', link: function (scope, element, attrs, ctrl) &#123; element.bind('input', function () &#123; scope.$apply(function () &#123; ctrl.$setViewValue(element.html()); &#125;); &#125;); ctrl.$render = function () &#123; element.html(ctrl.$viewValue); &#125;; &#125; &#125;;&#125;); 或者 1234567891011121314151617181920212223app.directive('contenteditable', function() &#123; return &#123; restrict: 'A', // 只用于属性 require: '?ngModel', link: function(scope, element, attrs, ngModel) &#123; if (!ngModel) &#123; return; &#125; ngModel.$render = function() &#123; element.html(ngModel.$viewValue || ''); &#125;; element.on('blur keyup change input', function() &#123; scope.$apply(readViewText); &#125;); function readViewText() &#123; var html = element.html(); if (attrs.stripBr &amp;&amp; html === '&lt;br&gt;') &#123; html = ''; &#125; ngModel.$setViewValue(html); &#125; &#125;&#125;; 这样我们就可以实现数据的双向绑定了。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Redux(一)-Redux介绍]]></title>
    <url>%2F2017%2F08%2F10%2FReact%20Native%20Redux%2FReact%20Native%20Redux(%E4%B8%80)%20-%20Redux%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言：本文将着重梳理清 redux 使用中的各个关键词的概念，以加深对redux的理解项目地址 redux是什么 redux 是 JavaScript 状态容器，提供对 JavaScript 应用状态的管理 redux安装 安装 react-redux 1npm install --save react-redux 安装 redux 1npm install --save redux 安装 redux-thunk 1npm install --save redux-thunk redux介绍redux由三部分组成：Action、Reducer、Store Action：事件的发起者(动作)，由用户或程序触发 Reducer：根据Action 类型来做出不同的响应，返回新的 state Store：存储 state 的集合 当由用户或者程序触发某一个具体的动作时，Reducer 将对 Action 进行识别, 并返回新的state，最终存储在 store 中的 state 发生改变，从而导致界面的变化。 好处 单一数据源：数据只存在于 store 中，无论是开发还是调试都方便很多 state 是只读的：只有通过触发 action 才能修改 state Provider Provider 这个模块是作为整个 App 的容器，在你原有的 App Container 的基础上再包上一层，它的工作很简单，就是接受 Redux 的 store 作为 props dispatch dispatch 有分发之意。我们知道由用户或者程序触发的 Action 由 Reducer 做出响应从而引起 state 的改变。而 dispatch 就扮演了他们两者中的传播媒介。简单来说：首先 store 中维护了一个 state，我们 dispatch 一个 action 会触发 reducer 检测，接下来 reducer 根据这个 action 更新 state connect connect方法的作用是连接 react 组件和 store，也就是说通过 connect 方法子组件可以获取 store 中的 state 和 dispatch。redux 的 connect 的含义是可以连接任意函数，这些函数的参数可以注入 store、state、dispatch。connect 可以将组件和 reducer 相关联。 combineReducers 我们知道 reducer 是一个纯函数，接收已有的的 state 和 action，返回新的 state。当state比较多或复杂时，我们想让每个 reducer 只管理一部分 state 数据。而combineReducers 可以将所有的部分state友好的合并成一个全局的 state。其实combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理,然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象 applyMiddleware applyMiddleware是中间件，使用于 action 被发起之后，到达 reducer 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由 异步Action 当有网络请求的时候我们需要用到异步操作，这时候我们就需要使用到Thunk ``middleware 或者 redux-promise 中间件来 强烈建议Redux 中文文档Redux 英文文档]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Redux(二)-Redux使用]]></title>
    <url>%2F2017%2F08%2F05%2FReact%20Native%20Redux%2FReact%20Native%20Redux(%E4%BA%8C)%20-%20Redux%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言：redux重构(一)的时候大概讲了redux的各个部分的定义，这一部分主要讲解一下redux的具体使用。项目地址后端LeanCloud redux 使用1.项目目录结构 redux能用到的结构都在图上提现出来了，下面将以Login为例介绍每部分的具体内容 2.ActionTypes - 统一定义了action供别处调用123export const ERROR_ACTION = 'ERROR_ACTION';export const LOGIN_PERFORM_ACTION = 'LOGIN_PERFORM_ACTION';export const LOGIN_ACTION = 'LOGIN_ACTION'; 3.LoginAction - 事件的发起者12345678910111213141516171819202122232425262728293031323334353637import NetUtil from '../utils/NetUtil';import * as types from '../constants/ActionTypes';import Global from '../constants/Global'; export function performLoginAction(username, password) &#123; return (dispatch) =&gt; &#123; dispatch(performLogin()); let url = Global.LOGIN + "username=" + username + "&amp;password=" + password; NetUtil.get(url, function (res) &#123; if (res.hasOwnProperty('code')) &#123; dispatch(errorAction(res)); &#125; else &#123; dispatch(successLogin(res)) &#125; &#125;) &#125;&#125; function performLogin() &#123; return &#123; type: types.LOGIN_PERFORM_ACTION &#125;&#125; function successLogin(result) &#123; return &#123; type: types.LOGIN_ACTION, data: result &#125;&#125; function errorAction(result) &#123; return &#123; type: types.ERROR_ACTION, data: result &#125;&#125; 首先import我们前面定义的ActionType、Global(全局常量)、NetUtil(封装的网络请求) 然后我们dispatch(分发)各个动作，此处我们dispatch了performLogin这一动作，然后进行网络请求，根据请求成功与否我们dispatch了successLogin和errorAction这两个动作。 这里的主要区别就是动作的不同，这里仅仅是触发了不同的动作，之后我们会根据不同的动作来处理不同的数据。 在这里我们根据不同的action来选择是否传递数据以供reducer使用 4.LoginReducer - 根据Action的不同来改变state(数据)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import * as types from '../constants/ActionTypes'; const initialState = &#123; loading : false, data:&#123;&#125;, status: null&#125;; export default function login(state = initialState, action)&#123; switch (action.type) &#123; case types.LOGIN_PERFORM_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: true, status: 'doing' &#125;); case types.LOGIN_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: false, status: 'success', data: action.data &#125;); case types.ERROR_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: false, status: 'failed', data: action.data &#125;); default: return state; &#125;&#125;``` - 引入`ActionType `- 定义默认`state `的数据结构- 根据不同的`action`修改`state`，这里使用了ES6中的`Object.assign()`&gt; 这里的`action.data`是`LoginAction `传递过来的###### 5. 页面 -`action `的触发和`state `的改变```javascriptimport React, &#123;Component&#125; from 'react';import &#123; StyleSheet, View&#125; from 'react-native';import Util from '../utils/Util';import Tabs from '../containers/Tabs';import LoadingView from '../components/LoadingView'; import &#123;connect&#125; from 'react-redux';import TextButton from '../components/TextButton';import &#123;performLoginAction&#125; from '../actions/LoginAction';import Register from '../containers/Register';class Login extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; username: '', password: '' &#125;; &#125; render() &#123; const &#123;loginReducer&#125; = this.props; console.log(loginReducer); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;/View&gt; ) &#125; componentDidUpdate() &#123; const &#123;loginReducer&#125; = this.props; if (loginReducer.status === 'success') &#123; const &#123;navigator&#125; = this.props; navigator.push(&#123; name: 'Tabs', component: Tabs &#125;) &#125; if (loginReducer.status === 'failed')&#123; Util.showToastCenter(loginReducer.data.error); &#125; &#125; _login = () =&gt; &#123; const &#123;navigator, dispatch&#125; = this.props; let username = this.state.username; let password = this.state.password; if (Util.isEmpty(username)) &#123; Util.showToastCenter('用户名为空'); return; &#125; if (Util.isEmpty(password)) &#123; Util.showToastCenter('密码为空'); return; &#125; dispatch(performLoginAction(username, password)); &#125;;&#125; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#f5f5f5' &#125;&#125;); function mapStateToProps(state) &#123; const &#123;loginReducer&#125; = state; return &#123; loginReducer &#125;&#125; export default connect(mapStateToProps)(Login); 首先我们导入LoginAction里面的方法performLoginAction，在我们登录的时候调用 当触发登录动作的时候调用performLoginAction() 这样我们的整个流程就走通了，但是还差最后一步，当LoginReducer改变了state时，页面是怎么接受数据的呢？这就是下面要介绍的connect 6. connect: 连接 react 组件和 store12345678function mapStateToProps(state) &#123; const &#123;loginReducer&#125; = state; return &#123; loginReducer &#125;&#125;export default connect(mapStateToProps)(Login); mapStateToProps: 组件将会监听store的数据变化，只要store发生变化，就会回调该方法。然后我们就可以在componentWillReceiveProps()方法中接收state的改变。 到目前为止还差store中的state管理、reducer的管理 7.rootReducers1234567891011import &#123;combineReducers&#125; from 'redux';import loginReducer from './LoginReducer';import registerReducer from './RegisterReducer';import homeReducer from './HomeReducer'; const rootReducers = combineReducers(&#123; loginReducer, registerReducer, homeReducer&#125;);export default rootReducers; 将不同的reducer导入，并使用combineReducers 将他们统一管理 8.store12345678910111213141516171819202122232425262728293031323334import &#123;createStore, applyMiddleware&#125; from 'redux';import thunkMiddleware from 'redux-thunk';import rootReducers from '../reducers/rootReducers';const createStoreWithMiddleware = applyMiddleware(thunkMiddleware)(createStore);export default function configureStore(initialState) &#123; const store = createStoreWithMiddleware(rootReducers, initialState); return store;&#125;``` &gt; 所有的`state `都存储在这里###### 9. `Provider ````javascriptimport React, &#123;Component&#125; from 'react';import App from '../lifeStyle/App'; import configureStore from '../lifeStyle/store/configureStore';import &#123;Provider&#125; from 'react-redux'; const store = configureStore(); class root extends Component&#123; render()&#123; return( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; ) &#125;&#125; export default root; Provider 这个模块是作为整个 App 的容器，在你原有的 App Container 的基础上再包上一层，它的工作很简单，就是接受 Redux的 store 作为 props 梳理流程：首先是用户行为或者程序触发来生成不同的Action，此时根据不同的Action来生成不同的数据，store通过dispatch来触发action, 之后在Reducer中根据action type的不同将生成不同的state, store 中的state集合发生改变，并最终作用到界面上。整个过程可以理解为：UI – &gt; Action – &gt; Reducer – &gt; Store – &gt; UI, 完美的体现了单向数据流。这有点类似于Android中的MVP模式，将业务逻辑和页面的变化分割开来，各司其职互不干扰。]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native探索与设计(三)-ES5和ES6语法]]></title>
    <url>%2F2017%2F06%2F27%2FReact%20Native%20%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。 引用 在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样： 1234567//ES5var React = require("react-native");var &#123; Image, Text, PropTypes&#125; = React; //引用不同的React Native组件 在ES6里，import写法更为标准 123456//ES6import React, &#123; Image, Text, PropTypes&#125; from 'react-native'; 注意在React Native里，import直到0.12+才能正常运作。 导出单个类 在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出 12345//ES5var MyComponent = React.createClass(&#123; ...&#125;);module.exports = MyComponent; 在ES6里，通常用export default来实现相同的功能： 1234//ES6export default class MyComponent extends React.Component&#123; ...&#125; 引用的时候也类似： 12345//ES5var MyComponent = require('./MyComponent.js'); //ES6import MyComponent from './MyComponent.js'; 定义组件 在ES5里，通常通过React.createClass来定义一个组件类，像这样： 12345678//ES5var Photo = React.createClass(&#123; render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;); 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样： 12345678//ES6class Photo extends React.Component &#123; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 给组件定义方法 从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。 1234567891011121314151617181920212223//ES5 var Photo = React.createClass(&#123; componentWillMount: function()&#123; &#125;, render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;); //ES6class Photo extends React.Component &#123; componentWillMount() &#123; &#125; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 定义组件的属性类型和默认属性 在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现 1234567891011121314151617181920//ES5 var Video = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; autoPlay: false, maxLoops: 10, &#125;; &#125;, propTypes: &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return ( &lt;View /&gt; ); &#125;,&#125;); 在ES6里，可以统一使用static成员来实现 123456789101112131415161718//ES6class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;; // 注意这里有分号 render() &#123; return ( &lt;View /&gt; ); &#125; // 注意这里既没有分号也没有逗号&#125; 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思： 123456789101112131415161718//ES6class Video extends React.Component &#123; render() &#123; return ( &lt;View /&gt; ); &#125;&#125;Video.defaultProps = &#123; autoPlay: false, maxLoops: 10,&#125;;Video.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired,&#125;; 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化STATE ES5下情况类似， 12345678//ES5 var Video = React.createClass(&#123; getInitialState: function() &#123; return &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;,&#125;) ES6下，有两种写法： 123456//ES6class Video extends React.Component &#123; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; 推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）： 123456789//ES6class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 把方法作为回调提供 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 1234567891011121314//ES5var PostInfo = React.createClass(&#123; handleOptionsButtonClick: function(e) &#123; // Here, 'this' refers to the component instance. this.setState(&#123;showOptionsModal: true&#125;); &#125;, render: function()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick&#125;&gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125;); 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用 1234567891011121314151617//ES6class PostInfo extends React.Component&#123; handleOptionsButtonClick(e)&#123; this.setState(&#123;showOptionsModal: true&#125;); &#125; render()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125; onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125; &gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125; 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 1234567891011121314151617181920212223242526// 错误的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener('change', this.onAppPaused.bind(this)); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this.onAppPaused.bind(this)); &#125; onAppPaused(event)&#123; &#125;&#125;// 正确的做法class PauseMenu extends React.Component&#123; constructor(props)&#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount()&#123; AppStateIOS.addEventListener('change', this._onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this._onAppPaused); &#125; onAppPaused(event)&#123; &#125;&#125; 从这个帖子中我们还学习到一种新的做法： 123456789101112// 正确的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener('change', this.onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this.onAppPaused); &#125; onAppPaused = (event) =&gt; &#123; //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针 &#125;&#125; Mixins 在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin 12345678var PureRenderMixin = require('react-addons-pure-render-mixin');React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。尽管如果要继续使用mixin，还是有一些第三方的方案可以用.不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，上文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式： 12345678910111213141516171819202122232425//Enhance.jsimport &#123; Component &#125; from "React"; export var Enhance = ComposedComponent =&gt; class extends Component &#123; constructor() &#123; this.state = &#123; data: null &#125;; &#125; componentDidMount() &#123; this.setState(&#123; data: 'Hello' &#125;); &#125; render() &#123; return &lt;ComposedComponent &#123;...this.props&#125; data=&#123;this.state.data&#125; /&gt;; &#125;&#125;;//HigherOrderComponent.jsimport &#123; Enhance &#125; from "./Enhance"; class MyComponent &#123; render() &#123; if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;; return &lt;div&gt;&#123;this.data&#125;&lt;/div&gt;; &#125;&#125; export default Enhance(MyComponent); // Enhanced component 用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ES6+带来的其它好处 ######解构&amp;属性延展 结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签： 1234567891011121314class AutoloadingPostsGrid extends React.Component &#123; render() &#123; var &#123; className, ...others, // contains all properties of this.props except for className &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; React Native 的ES5/ES6写法对照表]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native探索与设计(二)-JSX语法和ES6语法]]></title>
    <url>%2F2017%2F06%2F26%2FReact%20Native%20%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[JSX语法 JSX: 即JavaScript XML 是一种在React组建内部构建标签的类XML语法。增强React程序组件的可读性 React的核心机制之一就是虚拟DOM: 可以在内存中创建虚拟DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。1、示例123456789render: function() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;/View&gt; );&#125; 2、JS表达式 ReactJS中约定自定义的组件标签首字母一定要大写，这样区别于HTML标签 表达式用{}包起来，不要加引号，加引号就会被当成字符串。 JSX是HTML和JavaScript混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析 3、关于样式 普通内联样式:&#123;&#123;&#125;&#125;,第一层{}是表达式，第二层{}是js对象 1&lt;View style=&#123;&#123;fontSize:40, width:80,&#125;&#125;&gt; &lt;/View&gt; 调用样式表:{样式类.属性} 1&lt;View style=&#123;styles.container&#125;&gt;&lt;/View&gt; 样式表和内联样式共存:{[]} 1&lt;View style=&#123;[styles.container, &#123;fontSize:40, width:80&#125;]&#125;&gt; 多个样式表:{[样式类1， 样式类2]} 1&lt;View style=&#123;[styles.container, styles.color]&#125;&gt; ES6语法 展开运算符：允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。 用于函数调用1myFunction(...iterableObj); 用于数组字面量1[...iterableObj, 4, 5, 6] apply方法能劫持另外一个对象的方法，继承另外一个对象的属性 123function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction.apply(null, args); 这是使用了apply方法来遍历的参数，但是在ES6下我们还可以像下面这样写 123function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction(...args); 数组字面量展开操作符可以简化数组间的操作如下： 123var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); 可以将一个数组在任何位置插入另一个数组： 12var arr1 = [3, 4];var lyrics = [2, ...arr1, 5, 6]; 解构赋值解构赋值是ES6的特性 1234let [arg1,arg2,...arg3] = [1, 2, 3, 4];arg1 //1arg2 //2arg3 //['3','4'] 解构赋值中展开运算符只能放在最后 1let [arg1,...arg2,arg3] = [1, 2, 3, 4]; //报错 箭头函数(Arrow Functions)：箭头函数的产生主要有两个目的更：简洁的语法和与父作用域共享关键字this 简洁1x =&gt; x * x 相当于 123function (x) &#123; return x * x;&#125; 无参数1() =&gt; 5 一个参数1x =&gt; x * x 两个参数1(x, y) =&gt; x * y 可变参数1234567(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 返回对象1x =&gt; (&#123; foo: x &#125;) 通过上面的一些格式，我们可以看出函数体的内容和普通的函数比更简洁 this每个新定义的函数都有其自己的 this 值，我们通过下面几段代码来看看this的作用域问题：123456function Person() &#123; this.age = 0; //this 指向的就是对象自己 setInterval(function growUp() &#123; this.age++; // 在非严格模式下，this指向的是函数内部 &#125;, 1000);&#125; 可以通过新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。1234567function Person() &#123; var that = this; that.age = 0; //that 指向的就是对象自己 setInterval(function growUp() &#123; that.age++; //that指向的是我们期望的指向 &#125;, 1000);&#125; 用箭头函数就可以这么写：123456function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向了 person 对象 &#125;, 1000);&#125; argument变量箭头函数与普通函数还有一个区别就是，它没有自己的arguments变量 React Native中也用到了ES6的let, const, import, class，所以开发前最好先对这些基础知识有个了解]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native探索与设计(一)]]></title>
    <url>%2F2017%2F06%2F25%2FReact%20Native%20%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[React Native探索与设计(一) 1. React Native有什么优点 跨平台 动态更新 代码复用 最大的优势就是既有Web的热更新优势，又有接近Native的性能 2. React Native VS Hybrid 性能： Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少。 用户体验：React Native 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。 3. React Native VS Weex Weex bug比较多 社区、文档弱，GitHub Issue 基本是中文:这就意味着Weex并没有国际化，Weex还有很长的路要走 4. React Native 劣势 学习成本：而 React Native 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大(ES6的箭头函数、展开运算符) 首次加载耗时：React Native 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新(在发布 client 时内置一个写好的 js 文件在本地作缓存用) 5. React Native 运行机制 在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件 读取 JavaScript 源码。JavaScript 加载进内存, JSX 代码已经被转化成原生的 JavaScript 代码 初始化模块信息。通过initModulesWithDispatchGroup()找到所有需要暴露给JavaScript的类 初始化 JavaScript 代码的执行器，即 RCTJSCExecutor对象 生成模块列表并写入 JavaScript 端 执行 JavaScript 源码 React Native运行机制详解 6. React Native 开发环境搭建 IDE：Nuclide、Deco、Webstorm、Sublime Text 环境搭建 一、安装Homebrew。Homebrew是Mac OSX的包管理器，我们需要通过 Homebrew安装开发React Native的相关软件包。 二、安装Node.js。 1$brew install node 三、安装watchman。watchman是Facebook用于监视JavaScript文件改动的开源项目。 1$brew install watchman 四、安装flow。flow是Facebook开源的一个JavaScript静态类型检查器，用于发现JavaScript程序中的类型错误。 1234567$brew install flow``` &gt; 五、安装`react-native-cli`。`react-native-cli`是`React Native`的命令行工具，安装`react-native-cli`后我们就能够通过`react-native`相关命令管理`ReactNative`工程。```javascript$npm install -g react-native-cli 目录结构 android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行 node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成； js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自动生效。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native TextInput 高度自适应]]></title>
    <url>%2F2017%2F06%2F23%2FReact%20Native%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FReact%20Native%20TextInput%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[有时我们需要根据默认的文字来显示TextInput的高度，而且可以随着文字的输入自动增加TextInput的高度。下面我们就来看一下这个是如何实现的： TextInput属性介绍 代码伺候(去除无关代码)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Created by Cral-Gates on 2017/5/11. */import React, &#123;Component&#125; from 'react';import &#123; StyleSheet, Text, View, TextInput, ScrollView&#125; from 'react-native';import NavigationBar from '../component/NavigationBar';import NetUtil from '../utils/NetUtil';import Global from '../utils/Global'; class NoteDetail extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; noteContent: '', height: 50, &#125; &#125; componentDidMount() &#123; this.setState(&#123; noteContent: this.props.noteDetail.content, &#125;); &#125; render() &#123; return ( &lt;View&gt; &lt;ScrollView&gt; &lt;TextInput style=&#123;[styles.noteDetailContent, &#123;height: this.state.height&#125;]&#125; multiline=&#123;true&#125; secureTextEntry=&#123;false&#125; underlineColorAndroid=&#123;'transparent'&#125; value=&#123;this.state.noteContent&#125; onChangeText=&#123;(noteContent) =&gt; this.setState(&#123;noteContent&#125;)&#125; onChange=&#123;() =&gt; this.onChange.bind(this)&#125; onContentSizeChange=&#123;(event) =&gt; this.onContentSizeChange(event)&#125;/&gt; &lt;/ScrollView&gt; &lt;/View&gt; ) &#125; onChange = (event) =&gt; &#123; this.setState(&#123; noteContent: event.nativeEvent.text, height: event.nativeEvent.contentSize.height &#125;); &#125;; onContentSizeChange = (event) =&gt; &#123; this.setState(&#123; height: event.nativeEvent.contentSize.height &#125;); &#125;&#125; const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: '#f5f5f5' &#125;, noteDetailTitle: &#123; backgroundColor: 'white', marginTop: 10, marginBottom: 2, marginLeft: 20, marginRight: 20, height: 35, fontSize: 18, fontWeight: '600' &#125;, noteDetailContent: &#123; backgroundColor: 'white', marginLeft: 20, marginRight: 10, lineHeight: 20, fontSize: 16 &#125;&#125;); export default NoteDetail; 首先创建构造函数 1234567constructor(props) &#123; super(props); this.state = &#123; noteContent: '', //笔记内容 height: 50, //默认高度 &#125; &#125; 然后设置默认的笔记内容 12345componentDidMount() &#123; this.setState(&#123; noteContent: this.props.noteDetail.content // 这是从上一个页面传递过来的值 &#125;);&#125; TextInput属性介绍123456789&lt;TextInput style=&#123;[styles.noteDetailContent, &#123;height: this.state.height&#125;]&#125; multiline=&#123;true&#125; secureTextEntry=&#123;false&#125; underlineColorAndroid=&#123;'transparent'&#125; value=&#123;this.state.noteContent&#125; onChangeText=&#123;(noteContent) =&gt; this.setState(&#123;noteContent&#125;)&#125; onChange=&#123;() =&gt; this.onChange.bind(this)&#125; onContentSizeChange=&#123;(event) =&gt; this.onContentSizeChange(event)&#125;/&gt; onChange function 监听方法,文本框内容发生改变回调方法 12345onChangeText = (text) =&gt; &#123; this.setState(&#123; noteContent: text &#125;)&#125; onChangeText function监听方法，文本框内容发生改变回调方法，该方法主要是监听输入框文字的变化 12345onChange = (event) =&gt; &#123; this.setState(&#123; noteContent: event.nativeEvent.text &#125;);&#125;; onContentSizeChange function监听方法，当文本框的高度发生变化时回调该方法。当TextInput的高度可变时，调用onLayout方法并将宽高传递给它，并重新绘制该组件。 12345onContentSizeChange = (event) =&gt; &#123; this.setState(&#123; height: event.nativeEvent.contentSize.height &#125;);&#125; 至此就大功告成了！有什么问题可留言交流]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native AsyncStorage 封装]]></title>
    <url>%2F2017%2F06%2F22%2FReact%20Native%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FReact%20Native%20AsyncStorage%20%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在Android开发中有一个以key-value形式轻量级的数据存储方式—SharedPreferences, 类似的React Native中也有一个–AsyncStorage AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的 API1static getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) 读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 1static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) 将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 1static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) 删除一个字段。返回一个Promise对象。 封装1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';import &#123;Component&#125; from 'react';import &#123; AsyncStorage&#125; from 'react-native';import JsonUtil from '../utils/JsonUtil' class StorageUtil extends Component &#123; /* * 保存 * */ static save(key, value, callback) &#123; return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value), callback); &#125; /* * 获取 * */ static get(key) &#123; return AsyncStorage.getItem(key).then((value) =&gt; &#123; const jsonValue = JsonUtil.strToJson(value); return jsonValue; &#125;) &#125; /* * 更新 * */ static update(key, value) &#123; StorageUtil.get(key).then((item) =&gt; &#123; value = typeof value === 'string' ? value : Object.assign(&#123;&#125;, item, value); return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value)); &#125;) &#125; /* * 删除 * */ static delete(key, callback) &#123; AsyncStorage.removeItem(key, callback); &#125;&#125; export default StorageUtil; 其中JsonUtil是封装的一个Json格式转换的工具类，其中保存和删除添加了一个回调函数 调用保存123StorageUtil.save('sessionToken', res.sessionToken, function () &#123; console.log('成功');&#125;); 调用12345StorageUtil.get('sessionToken').then((username) =&gt; &#123; this.setState(&#123; username:username &#125;)&#125;);]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 自定义组件]]></title>
    <url>%2F2017%2F06%2F21%2FReact%20Native%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FReact%20Native%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[通过继承Component来创建组件类 123class TextButton extends Component &#123;&#125; 定义组件的propTypes(props类型)和defaultProps(props默认值) 12345678910111213static propTypes = &#123; text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number &#125;; static defaultProps = &#123; color: 'white', backgroundColor: '#FFDE00', fontSize:14 &#125;; 其中PropTypes的类型有：array，bool，func，number，object， string，symbol 渲染界面，引用props值 123456789render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this.props.onPress&#125;&gt; &lt;View style=&#123;[&#123;backgroundColor:this.props.backgroundColor&#125;]&#125;&gt; &lt;Text style=&#123;&#123;fontSize:this.props.fontSize, color:this.props.color&#125;&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125; 导出组件 1export default TextButton; 下面是完整代码：12345678910111213141516171819202122232425262728293031323334353637'use strict'; import React, &#123;Component, PropTypes&#125; from 'react';import &#123; StyleSheet, TouchableOpacity, Text, View&#125; from 'react-native'; class TextButton extends Component &#123; static propTypes = &#123; text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number &#125;; static defaultProps = &#123; color: 'white', backgroundColor: '#FFDE00', fontSize:14 &#125;; render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this.props.onPress&#125;&gt; &lt;View style=&#123;[&#123;backgroundColor:this.props.backgroundColor&#125;]&#125;&gt; &lt;Text style=&#123;&#123;fontSize:this.props.fontSize, color:this.props.color&#125;&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; export default TextButton; 引用123456789//首先导入组件import TextButton from '../component/TextButton';//然后在render渲染&lt;TextButton style=&#123;styles.register&#125; text=&#123;'测试文字'&#125; onPress=&#123;() =&gt; this._test()&#125; color=&#123;'#FFDE00'&#125; backgroundColor=&#123;'transparent'&#125;/&gt;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native网络请求和Json-String封装]]></title>
    <url>%2F2017%2F06%2F20%2FReact%20Native%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FReact%20Native%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Serialization 通过以下实例我们实现 Json与String、Json与Map的数据转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'use strict';import React, &#123;Component&#125; from 'react'; class JsonUtil extends Component &#123; /* * 字符转换为JSON * */ static strToJson(data) &#123; return JSON.parse(data); &#125; /* * JSON转换为字符 * */ static jsonToStr(data) &#123; return JSON.stringify(data); &#125; /* * map转换为json * */ static mapToJson(map) &#123; return JSON.stringify(JsonUtil.strMapToObj(map)); &#125; /* * json转换为map * */ static jsonToMap(jsonStr) &#123; return JsonUtil.objToStrMap(JSON.parse(jsonStr)); &#125; /* * map转化为对象（map所有键都是字符串，可以将其转换为对象） * */ static strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return obj; &#125; /* * 对象转换为Map * */ static objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap; &#125;&#125; export default JsonUtil; 网络请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495'use strict';import React, &#123;Component&#125; from 'react';class NetUtil extends Component &#123;static DouB_Api = 'https://api.douban.com/v2/movie/top250?start=0&amp;count=20';/** * get请求 *url : 请求地址 *callback : 回调函数 */static get(url, callback) &#123; var fetchOptions = &#123; method: 'GET', headers: &#123; 'X-LC-Id': 'M401fErHUKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt1LvQh1JDRUpRAqq' &#125; &#125;; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)); &#125;).done();&#125;/** * delete请求 *url : 请求地址 *callback : 回调函数 */static delete(url, callback) &#123; var fetchOptions = &#123; method: 'DELETE', headers: &#123; 'X-LC-Id': 'M401fErHUKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt1LvQh1JDRUpRAqq' &#125; &#125;; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)); &#125;).done();&#125;/** * post请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */static postJson(url, data, callback) &#123; var fetchOption = &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'X-LC-Id': 'M401fErHDKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt34vQh1JDRUpRAqq' &#125;, body: JSON.stringify(data) &#125;; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)) &#125;) .done();&#125;/** * put请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */static putJson(url, data, callback) &#123; var fetchOption = &#123; method: 'PUT', headers: &#123; 'Content-Type': 'application/json', 'X-LC-Id': 'M401fErHUPKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt34vQh1JDRUpRAqq' &#125;, body: JSON.stringify(data) &#125;; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)) &#125;) .done();&#125;export default NetUtil; 网络请求使用123456789101112131415161718import NetUtil from '../utils/NetUtil';import JsonUtil from '../utils/JsonUtil'; _getMyNoteBook = () =&gt; &#123; let _this = this; let username = this.state.username; let params = &#123; "author": username &#125;; let url = Global.NOTEBOOK + JsonUtil.jsonToStr(params); NetUtil.get(url, function (response) &#123; console.log(response); _this.setState(&#123; notebooks: _this.state.notebooks.cloneWithRows(response.results), noteArray: response.results &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova插件开发-Android获取资源Id]]></title>
    <url>%2F2017%2F06%2F10%2FAngularJs%2FgetResourcesId%2F</url>
    <content type="text"><![CDATA[在制作Cordova插件时不能通过R文件来寻找资源Id，因为R文件是不断变化的，所以我们必须要通过资源名称来获取Id，下面就介绍一下资源id的获取: 使用Resources 类的 getIdentifier方法 通过资源名称虚招布局文件的id 1234567891011121314151617181920212223242526272829303132333435private int getResId(String resourceName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(resourceName,"layout",getPackageName()); return resId;&#125; ``` - 获取字符串id```javascriptprivate int getStringId(String stringName)&#123; Resources resources = getResources(); int resId =resources.getIdentifier(stringName,"string", getPackageName()); return resId;&#125; ``` - 获取控件id```javascriptprivate int getId(String idName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(idName, "id", getPackageName()); return resId;&#125;``` - 获取动画id ```javascriptprivate int getAnimId(String idName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(idName, "anim", getPackageName()); return resId;&#125; 作为一个Android开发者来说，也许你已经发现上面代码的不同点了，就是getIdentifier()里面的第二个参数的不同，我们可以通过替换这个参数来达到大部分的寻找资源id``（example：id, string, anim, attr, drawable, layout, color, menu, styles...） 通过Java的强大的反射机制获取资源id 通过反射获取一个资源id public int getAttrId(String attrName) { try { Class&lt;?&gt; loadClass = mContext.getClassLoader().loadClass(mContext.getPackageName() + ".R"); Class&lt;?&gt;[] classes = loadClass.getClasses(); for (int i = 0; i &lt; classes.length; i++) { if (classes[i].getName().equals(mContext.getPackageName() + ".R$attr")) { Field field = classes[i].getField(attrName); int attrId = field.getInt(null); return attrId; } } } catch (Exception e) { e.printStackTrace(); } return 0; } 首先使用反射能达到上面的获取一个id的情况，但是比较麻烦，当需要返回一个数组我们就不得不使用这种方法了 private int[] getStyleableArryId(String styleableName){ try { Class&lt;?&gt; loadClass = getContext().getClassLoader().loadClass(getContext().getPackageName() + ".R"); Class&lt;?&gt;[] classes = loadClass.getClasses(); for(int i=0 ;i&lt;classes.length ;i++){ Class&lt;?&gt; resClass = classes[i]; if(resClass.getName().equals(getContext().getPackageName() + ".R$styleable")){ Field[] fields = resClass.getFields(); for (int j = 0; j &lt; fields.length; j++) { if(fields[j].getName().equals(styleableName)){ int[] styleable = (int[]) fields[j].get(null); return styleable; } } } } } catch (Exception e) { e.printStackTrace(); } return null; } 但是在设置styleable的资源id的时候，如果你是自定义的View，如果需要引入自定义的attr,比如这样：public WheelVerticalView(Context context, final AttributeSet attrs) { this(context, attrs, R.attr.abstractWheelViewStyle); this(context, attrs, 0); } 那么你是不能通过上面的方法，来获取资源文件的，因为这是一个构造器，你只能另找它法了。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs固定大小的图片防止变形]]></title>
    <url>%2F2017%2F05%2F15%2FAngularJs%2FimageCover%2F</url>
    <content type="text"><![CDATA[使用情景：当我们遇到需要固定大小的图片，而又不想让图片变形 这个时候我要应该要想到的是css中的background相关属性 12345.backImg &#123; 'background-image': 'url('')', 'background-size': 'cover', 'background-position': 'center'&#125; 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分可能无法显示在背景定位区域中。这样我们就可以让图片局部显示并达到了图片没有变形的效果 下面是AngularJs把它封装为相应的指令 12345678910111213angular.module('imgTransformModule', []) .directive('imgTransform', function () &#123; return function (scope, element, attrs) &#123; attrs.$observe('imgTransform', function (value) &#123; element.css(&#123; 'background-image': 'url(' + value + ')', 'background-size': 'cover', 'background-position': 'center' 'display':'inline-block'; &#125;); &#125;); &#125;; &#125;); 调用 1&lt;div class="img-Transform" img-transform="&#123;&#123;url&#125;&#125;"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova修改相册插件和监听Android返回]]></title>
    <url>%2F2017%2F05%2F10%2FAngularJs%2Fionic%E7%9B%91%E5%90%ACAndroid%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[ionic混合开发调用Android系统相册，官方的cordova-image-picker插件在直接用的时候会在Android6.0以上的版本由于没有获得相应的存储权限而闪退。 解决方法一： 在原有的cordova插件上面改动，添加了动态授权，我放在了github 用法和原来的相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 function getImgPicker() &#123; var options = &#123; maximumImagesCount: 1, width: 800, height: 800, quality: 80, title:'', message:'', outputType:1 &#125;; window.imagePicker.getPictures(function (results) &#123; vm.userInfo.Url = results[0]; console.log(vm.userInfo.Url); vm.upload(vm.userInfo.Url); &#125;, function (err) &#123; publicMethod.showLoadingNoBackdrop('调取相册失败'); console.log(angular.toJson(error, true)); &#125;, options); &#125; ``` * 解决方法二： - 添加一个新的插件，专门获取所需的权限[cordova-plugin-android-permissions](https://www.npmjs.com/package/cordova-plugin-android-permissions)，下面是用法。 ```javascript var permissions = cordova.plugins.permissions; permissions.hasPermission(permissions.CAMERA, checkPermissionCallback, null); function checkPermissionCallback(status) &#123; if(!status.hasPermission) &#123; var errorCallback = function() &#123; console.warn('Camera permission is not turned on'); &#125; permissions.requestPermission( permissions.CAMERA, function(status) &#123; if(!status.hasPermission) errorCallback(); &#125;, errorCallback); &#125; &#125; ``` &gt; `ionic` 监听`Android`的返回键和双击退出程序(直接上代码)```javascript$ionicPlatform.registerBackButtonAction(function (e) &#123; e.preventDefault(); //判断处于哪个页面时双击退出 if ($location.path() == '/tab/home' || $location.path() == '/tab/activity' || $location.path() == '/tab/person' || $location.path() == '/tab/share' || $location.path() == '/tab/study') &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else &#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show("再按一次退出系统", "short", "bottom"); $timeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; else if ($location.path() == '/blueprint-list' || $location.path() == '/megagame-list') &#123; $state.go('tab.activity'); //此处判断当前所处的View,并返回到tab页 &#125; else if ($ionicHistory.backView()) &#123; $ionicHistory.goBack(); &#125; else &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else &#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show("再按一次退出系统", "short", "bottom"); $timeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; return false;&#125;, 101);]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MVC和MVP的区别和理解]]></title>
    <url>%2F2017%2F05%2F05%2FAndroid%2FAndroid%20MVC%E4%B8%8EMVP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MVC架构：MVC就是Model-View-Controller，它们的作用是：123(数据模型)Model：数据的封装和保存，业务逻辑和实体模型(视图)View：视图界面，对应于布局文件(控制器)Controller：业务逻辑，对应于Activity、Fragment等 它们之间的关系如下图所示：View传送指令到Controller,Controller完成业务逻辑后，改变Model的状态，Model将新的数据发送到View，这就是MVC模式的处理逻辑。 MVP架构：MVP是Model-View-Presenter，它们的作用如下： 123Model：业务逻辑和实体模型，用来操作实际的数据，包含Bean和Model的抽象接口来降低耦合。View：就是Android中的视图，需要建立一个View的抽象接口View Interface。通过实现View的接口来实现View与Presenter的交互，从而降低耦合。对应于Activity，负责View的绘制与用户交互；Presenter：View和Model的中间枢纽，处理和用户交互的逻辑。 MVP和MVC的对比：MVP架构：123View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。Presenter与View的交互是通过接口来进行的。通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。 MVC架构：123View可以与Model直接交互。Controller是基于行为的，并且可以被多个View共享。可以负责决定显示哪个View。 通过一个简单的例子来理解MVP模式：View层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * ViewInterface * 定义一些通用的view接口 */public interface LoadDataView &#123; /*** * 耗时操作，加载数据，显示Progress */ void showLoading(); /*** * 隐藏Progress */ void hideLoading();&#125;/** * 更细小的，用来显示图书细节的View接口 */public interface LoadBookView extends LoadDataView &#123; void showDetailsView(BookEntity entity);&#125;/*** * Fragment,属于View层，实现了ViewInterface（LoadBookView） */public class BookDetailFragment extends Fragment implements LoadBookView&#123; /**图书条形码ISBN号*/ public static final String ISBN = "9787121060748"; /**持Presenter对象*/ private BookDetailsPresenter presenter; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); initWidget(); presenter = new BookDetailsPresenter(getActivity(), ISBN); // 实例化一个presenter对象 presenter.setView(this); //让Presenter持一个ViewInterface实例（LoadBookView） presenter.loadData(); //告诉Presenter快给我加载Data &#125; @Override public void showDetailsView(BookEntity entity) &#123; //更新UI等操作 &#125; @Override public void showLoading() &#123; rlProgress.setVisibility(View.VISIBLE); &#125; @Override public void hideLoading() &#123; rlProgress.setVisibility(View.GONE); &#125;&#125; 2、Presenter层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BookDetailsPresenter &#123; /**持一个Model层的对象，用来从网页接口Rest Api中提取数据*/ private RestApi restApi = null; /**一个ViewInterface对象，用来回调Data给View*/ private LoadBookView loadBookView; private String isbn; public BookDetailsPresenter(Context context, String isbn) &#123; restApi = new RestApiImpl(context); this.isbn =isbn; &#125; public void setView(LoadBookView loadBookView) &#123; this.loadBookView = loadBookView; &#125; public void loadData() &#123; loadBookView.showLoading(); //耗时操作，开个线程异步的加载数据 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; restApi.getBookDetailByIsbn(isbn, bookDetailsCallback); &#125; &#125;); thread.start(); &#125; //匿名内部类，接收bookDetailCallback的回调数据 private RestApi.BookDetailsCallback bookDetailsCallback = new RestApi.BookDetailsCallback() &#123; @Override public void onBookEntityLoaded(BookEntity bookEntity) &#123; notifyDataLoadedSuccessful(bookEntity); BookDetailsPresenter.this.loadBookView.hideLoading(); &#125; @Override public void onError(Exception e) &#123; //异常后的相关处理 &#125; &#125;; /*** * 通知获取数据成功了，赶快通知UI更新吧 */ private void notifyDataLoadedSuccessful(final BookEntity bookEntity) &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; BookDetailsPresenter.this.loadBookView.showDetailsView(bookEntity); &#125; &#125;); &#125; &#125; 3、Model层： 123456789101112131415161718192021222324252627/**** 整个应用程序需要的数据实体类*/public class BookEntity &#123; //一些set，get方法&#125;/** * 一个接口，用来从rest api api获得数据，它的实现在RestApiImpl中 */public interface RestApi &#123; String API_ISBN_BASE_URL = "https://api.douban.com/v2/book/isbn/"; /*** * 更细小的接口，用来将获取到的数据，回调给它的调用者 */ interface BookDetailsCallback &#123; void onBookEntityLoaded(BookEntity bookEntity); void onError(Exception e); &#125; /** * 从网络获取数据，然后通过bookDetailCallback回调给Presenter * @param isbn * @param bookDetailsCallback */ void getBookDetailByIsbn(final String isbn, final BookDetailsCallback bookDetailsCallback);&#125; 参考文章： http://www.jianshu.com/p/95c9088eef4f http://www.codeceo.com/article/mvp-android.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android观察者模式]]></title>
    <url>%2F2017%2F05%2F05%2FAndroid%2FAndroid%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式理解观察者模式 Observer 观察者模式定义了一个一对多的依赖关系，让多个观察者对象同时监听一个主题对象 当这个主题对象改变时，会通知所有的观察者，让他们能够自动的更新自己 观察者模式的组成 抽象主题：把所有的对观察者对象的引用保存在一个集合中，抽象主题提供一个接口，可以注册和移除观察者； 抽象观察者：为所有的观察者定义一个接口，当主题的数据更新时给登记的观察者提供通知； 具体主题：在具体主题内部状态改变时，给所有登记过的观察者发出通知； 具体观察者：实现抽象观察者提供的更新接口，以便本身的状态能够及时更新； 为便于理解可以把主题理解为被观察者 观察者模式的应用抽象观察者123456/** * 观察者 */public interface Observer &#123; void update();&#125; 抽象主题1234567891011121314151617181920/** * 主题（发布者、被观察者） */public interface Subject &#123; /** * 注册观察者 */ void registerObserver(Observer observer); /** * 移除观察者 */ void removeObserver(Observer observer); /** * 通知观察者 */ void notifyObservers(); &#125; 显示当前天气的公告牌的数据(具体观察者)1234567891011121314151617181920212223242526272829public class CurrentConditionsDisplay implements Observer, DisplayElement &#123; private WeatherData weatherData; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 public CurrentConditionsDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; this.weatherData.registerObserver(this); &#125; @Override public void display() &#123; System.out.println("当前温度为：" + this.temperature + "℃"); System.out.println("当前湿度为：" + this.humidity); System.out.println("当前气压为：" + this.pressure); &#125; @Override public void update() &#123; this.temperature = this.weatherData.getTemperature(); this.humidity = this.weatherData.getHumidity(); this.pressure = this.weatherData.getPressure(); display(); &#125;&#125; 用于获取数据的具体主题(被观察者)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class WeatherData implements Subject &#123; private List&lt;Observer&gt; observers; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 private List&lt;Float&gt; forecastTemperatures;//未来几天的温度 public WeatherData() &#123; this.observers = new ArrayList&lt;Observer&gt;(); &#125; @Override public void registerObserver(Observer observer) &#123; this.observers.add(observer); &#125; @Override public void removeObserver(Observer observer) &#123; this.observers.remove(observer); &#125; @Override public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure, List&lt;Float&gt; forecastTemperatures) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; this.forecastTemperatures = forecastTemperatures; measurementsChanged(); &#125; public float getTemperature() &#123; return temperature; &#125; public float getHumidity() &#123; return humidity; &#125; public float getPressure() &#123; return pressure; &#125; public List&lt;Float&gt; getForecastTemperatures() &#123; return forecastTemperatures; &#125;&#125; 用于公告牌显示的接口(观察者)123public interface DisplayElement &#123; void display();&#125; 公告牌CurrentConditionsDisplay实现了Observer和DisplayElement接口，在他们的构造方法中会调用WeatherData的registerObserver方法将自己注册成观察者，这样被观察者WeatherData就会持有观察者的应用，并将它们保存到一个集合中。当被观察者WeatherData状态发送变化时就会遍历这个集合，循环调用观察者公告牌更新数据的方法。后面如果我们需要增加或者删除公告牌就只需要新增或者删除实现了Observer和DisplayElement接口的公告牌就好了。 参考链接： http://www.cnblogs.com/mengdd/archive/2013/02/07/2908929.html http://www.jianshu.com/p/d55ee6e83d66 ]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac跨域]]></title>
    <url>%2F2017%2F04%2F22%2FTech%2FMac%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Mac： chrome49以前版本 1open -a "Google Chrome" --args --disable-web-security chrome49以后版本 1open -a /Applications/Google\ Chrome.app --args --disable-web-security --user-data-dir Safari 1open -a '/Applications/Safari.app' --args --disable-web-security Window： chrome.exe –disable-web-security PS：Mac–&gt;Chrome如果命令行不成功可以安装一个插件Allow-Control-Allow-Origin]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 微信sdk登录和分享]]></title>
    <url>%2F2017%2F04%2F20%2FAndroid%2FweChat-login%2F</url>
    <content type="text"><![CDATA[准备材料： 微信开发者账号 注册你的APP libammsdk.jar包 debug.keystore文件 准备工作 申请你的APPID 导入libammsdk.jar包 在AndroidManifest.xml中设置权限 123456789101112131415&lt;uses-permission android:name="android.permission.INTERNET"&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;``` - 注册APP到微信```java private static final String App_Id = "你注册的APP_ID";private IWXAPI api;public void registerToWX()&#123; api = WXAPIFactory.createWXAPI(this, App_Id, true); api.registerApp(App_ID);&#125; 分享： 分享(以分享图片为例) 直接触发分享图片按钮的点击事件 123456789101112131415161718192021222324findViewById(R.id.send_img).setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.send_img); WXImageObject imgObj = new WXImageObject(bmp); WXMediaMessage msg = new WXMediaMessage(); msg.mediaObject = imgObj; Bitmap thumbBmp = Bitmap.createScaledBitmap(bmp, 150, 150, true); bmp.recycle(); msg.thumbData = Util.bmpToByteArray(thumbBmp, true); SendMessageToWX.Req req = new SendMessageToWX.Req(); req.transaction = buildTransaction("img"); req.message = msg; req.scene = SendMessageToWX.Req.WXSceneTimeline; SendMessageToWX.Req.WXSceneSession; api.sendReq(req); finish(); &#125;&#125;); 其中req.scene表示分享选择分别代表分享到朋友圈和会话框 Util是一个图片处理的类 登录 登录需要重新APP到微信，需要触发回调,下面直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.lht.pan_android.wxapi;import org.apache.http.Header;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import com.alibaba.fastjson.JSON;import com.lht.pan_android.HttpUtil;import com.lht.pan_android.MainActivity;import com.lht.pan_android.R;import com.lht.pan_android.WeChatCodeBean;import com.loopj.android.http.AsyncHttpResponseHandler;import com.tencent.mm.sdk.modelbase.BaseReq;import com.tencent.mm.sdk.modelbase.BaseResp;import com.tencent.mm.sdk.modelmsg.SendAuth;import com.tencent.mm.sdk.openapi.IWXAPI;import com.tencent.mm.sdk.openapi.IWXAPIEventHandler;import com.tencent.mm.sdk.openapi.WXAPIFactory;public class WXEntryActivity extends Activity implements IWXAPIEventHandler &#123; private static final String TAG = "wechat"; private static final String APP_ID = "你的APP_Id"; private static final String APP_SECRET = "你的APP_secret"; private Button registerBtn; private IWXAPI api; private TextView tv; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.entry); registerBtn = (Button) findViewById(R.id.reg_btn); tv = (TextView) findViewById(R.id.log); api = WXAPIFactory.createWXAPI(this, APP_ID, true); registerBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; loginWithWeixin(); &#125; &#125;); api.handleIntent(getIntent(), this);&#125;//登录信息private void loginWithWeixin() &#123; if (api == null) &#123; api = WXAPIFactory.createWXAPI(this, APP_ID, false); &#125; if (!api.isWXAppInstalled()) &#123; Toast.makeText(this, "没有安装微信", Toast.LENGTH_SHORT).show(); return; &#125; api.registerApp(APP_ID); SendAuth.Req req = new SendAuth.Req(); req.scope = "snsapi_userinfo"; req.state = "com.lht.bridge.session"; api.sendReq(req);&#125;@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this);&#125; //实现了IWXAPIEventHandler@Overridepublic void onReq(BaseReq req) &#123; &#125;//实现了IWXAPIEventHandler@Overridepublic void onResp(BaseResp resp) &#123; code_code = ((SendAuth.Resp) resp).code; String result = null; switch (resp.errCode) &#123; case BaseResp.ErrCode.ERR_OK: result = "发送成功"; //此处进行数据请求，请求用户信息 Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_USER_CANCEL: result = "发送取消"; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_AUTH_DENIED: result = "发送被拒绝"; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; default: result = "发送返回"; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; &#125; Toast.makeText(this, result, Toast.LENGTH_LONG).show();&#125; 实现IWXAPIEventHandler接口，微信发送的请求将回调到onReq方法，发送到微信请求的响应结果将回调到onResp方法 在WXEntryActivity中将接收到的intent及实现了IWXAPIEventHandler接口的对象传递给IWXAPI接口的handleIntent方法 1234567①在Androidmanifest.xml中注册： &lt;activityandroid:name = ".wxapi.WXEntryActivity"android:exported = "true"/&gt; ②请求用户信息：微信需要先获取到code，再根据code获取access_token，根据access_token获取openId，最后根据access_token和openId获取用户信息 到此微信登录和分享的流程基本走通了，但是还有许多需要注意的问题 1、最最最重要的一点是登录需要单独写一个包,据说这样登录才能走微信自己的一套机制 格式为：包名.wxapi 类名：WXEntryActivity.java 2、导入的jar包问题，jar包导入的不对就可能导致获取code这一步出现问题，微信的jar包分为老版本和新版本，新版本的可以直接获取access_token，但是官网并没有说明怎么通过access_token获取用户信息，老版本的jar包是可以获取code的，然后自己根据code自己写网络请求(你没有看错，就是自己写网络请求)； 3、程序运行时一定要保证你的签名正确，如果需要更换你的key，windows下需要更换sdk/.android/debug.keystore以正确替换你的key 目前能想到的就这些了，有什么问题欢迎指出，最后吐槽一下微信登录竟然收费、微信的文档就呵呵了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>微信登录分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 博客搭建资源整理]]></title>
    <url>%2F2017%2F04%2F01%2FTech%2FHexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Next Theme版本5.1.0 hexo博客搭建遇到的问题处理和优化所需的资源 hexo开始搭建 底部Powered By algolia问题 三方服务 Cannot find module ‘hexo-util’ 配置文件属性说明 集成LeanCloud记录次数 hexo next 底部Logo栏(powered by) 添加友言评论 Hexo异常处理 主题配置 Hexo 持续优化(二) Hexo 持续优化(一) daovoice hexo 大小写404问题]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
