<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React Native 自定义组件]]></title>
      <url>%2F2017%2F06%2F21%2FReact%20Native%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[通过继承Component来创建组件类 class TextButton extends Component { } 定义组件的propTypes(props类型)和defaultProps(props默认值) static propTypes = { text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number }; static defaultProps = { color: &apos;white&apos;, backgroundColor: &apos;#FFDE00&apos;, fontSize:14 }; 其中PropTypes的类型有：array，bool，func，number，object， string，symbol 渲染界面，引用props值 render() { return ( &lt;TouchableOpacity onPress={this.props.onPress}&gt; &lt;View style={[{backgroundColor:this.props.backgroundColor}]}&gt; &lt;Text style={{fontSize:this.props.fontSize, color:this.props.color}}&gt;{this.props.text}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) } 导出组件 export default TextButton; 下面是完整代码：&apos;use strict&apos;; import React, {Component, PropTypes} from &apos;react&apos;; import { StyleSheet, TouchableOpacity, Text, View } from &apos;react-native&apos;; class TextButton extends Component { static propTypes = { text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number }; static defaultProps = { color: &apos;white&apos;, backgroundColor: &apos;#FFDE00&apos;, fontSize:14 }; render() { return ( &lt;TouchableOpacity onPress={this.props.onPress}&gt; &lt;View style={[{backgroundColor:this.props.backgroundColor}]}&gt; &lt;Text style={{fontSize:this.props.fontSize, color:this.props.color}}&gt;{this.props.text}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) } } export default TextButton; 引用//首先导入组件 import TextButton from &apos;../component/TextButton&apos;; //然后在render渲染 &lt;TextButton style={styles.register} text={&apos;测试文字&apos;} onPress={() =&gt; this._test()} color={&apos;#FFDE00&apos;} backgroundColor={&apos;transparent&apos;}/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native AsyncStorage 封装]]></title>
      <url>%2F2017%2F06%2F20%2FReact%20Native%20AsyncStorage%20%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[在Android开发中有一个以key-value形式轻量级的数据存储方式—SharedPreferences, 类似的React Native中也有一个–AsyncStorage AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的 APIstatic getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) 读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) 将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) 删除一个字段。返回一个Promise对象。 封装&apos;use strict&apos;; import {Component} from &apos;react&apos;; import { AsyncStorage } from &apos;react-native&apos;; import JsonUtil from &apos;../utils/JsonUtil&apos; class StorageUtil extends Component { /* * 保存 * */ static save(key, value, callback) { return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value), callback); } /* * 获取 * */ static get(key) { return AsyncStorage.getItem(key).then((value) =&gt; { const jsonValue = JsonUtil.strToJson(value); return jsonValue; }) } /* * 更新 * */ static update(key, value) { StorageUtil.get(key).then((item) =&gt; { value = typeof value === &apos;string&apos; ? value : Object.assign({}, item, value); return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value)); }) } /* * 删除 * */ static delete(key, callback) { AsyncStorage.removeItem(key, callback); } } export default StorageUtil; 其中JsonUtil是封装的一个Json格式转换的工具类，其中保存和删除添加了一个回调函数 调用保存StorageUtil.save(&apos;sessionToken&apos;, res.sessionToken, function () { console.log(&apos;成功&apos;); }); 调用 StorageUtil.get(&apos;sessionToken&apos;).then((username) =&gt; { this.setState({ username:username }) });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native网络请求和Json-String封装]]></title>
      <url>%2F2017%2F06%2F20%2FReact%20Native%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[Serialization&apos;use strict&apos;; import React, {Component} from &apos;react&apos;; class JsonUtil extends Component { /* * 字符转换为JSON * */ static strToJson(data) { return JSON.parse(data); } /* * JSON转换为字符 * */ static jsonToStr(data) { return JSON.stringify(data); } /* * map转换为json * */ static mapToJson(map) { return JSON.stringify(JsonUtil.strMapToObj(map)); } /* * json转换为map * */ static jsonToMap(jsonStr) { return JsonUtil.objToStrMap(JSON.parse(jsonStr)); } /* * map转化为对象（map所有键都是字符串，可以将其转换为对象） * */ static strMapToObj(strMap) { let obj = Object.create(null); for (let [k, v] of strMap) { obj[k] = v; } return obj; } /* * 对象转换为Map * */ static objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } } export default JsonUtil; 网络请求&apos;use strict&apos;; import React, {Component} from &apos;react&apos;; class NetUtil extends Component { static DouB_Api = &apos;https://api.douban.com/v2/movie/top250?start=0&amp;count=20&apos;; /** * get请求 *url : 请求地址 *callback : 回调函数 */ static get(url, callback) { var fetchOptions = { method: &apos;GET&apos;, headers: { &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; } }; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)); }).done(); } /** * delete请求 *url : 请求地址 *callback : 回调函数 */ static delete(url, callback) { var fetchOptions = { method: &apos;DELETE&apos;, headers: { &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; } }; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)); }).done(); } /** * post请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */ static postJson(url, data, callback) { var fetchOption = { method: &apos;POST&apos;, headers: { &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; }, body: JSON.stringify(data) }; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)) }) .done(); } /** * put请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */ static putJson(url, data, callback) { var fetchOption = { method: &apos;PUT&apos;, headers: { &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;X-LC-Id&apos;: &apos;M401fErHUPYhDKmgp0wjqVRX-gzGzoHsz&apos;, &apos;X-LC-Key&apos;: &apos;Jqnvt1Lmt34vQh1JDRUpRAqq&apos; }, body: JSON.stringify(data) }; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; { callback(JSON.parse(responseText)) }) .done(); } export default NetUtil; 网络请求使用import NetUtil from &apos;../utils/NetUtil&apos;; import JsonUtil from &apos;../utils/JsonUtil&apos;; _getMyNoteBook = () =&gt; { let _this = this; let username = this.state.username; let params = { &quot;author&quot;: username }; let url = Global.NOTEBOOK + JsonUtil.jsonToStr(params); NetUtil.get(url, function (response) { console.log(response); _this.setState({ notebooks: _this.state.notebooks.cloneWithRows(response.results), noteArray: response.results }); }); };]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native TextInput 高度自适应]]></title>
      <url>%2F2017%2F06%2F18%2FReact%20Native%20TextInput%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
      <content type="text"><![CDATA[有时我们需要根据默认的文字来显示TextInput的高度，而且可以随着文字的输入自动增加TextInput的高度。下面我们就来看一下这个是如何实现的： TextInput属性介绍代码伺候(去除无关代码)/** * Created by Cral-Gates on 2017/5/11. */ import React, {Component} from &apos;react&apos;; import { StyleSheet, Text, View, TextInput, ScrollView } from &apos;react-native&apos;; import NavigationBar from &apos;../component/NavigationBar&apos;; import NetUtil from &apos;../utils/NetUtil&apos;; import Global from &apos;../utils/Global&apos;; class NoteDetail extends Component { constructor(props) { super(props); this.state = { noteContent: &apos;&apos;, height: 50, } } componentDidMount() { this.setState({ noteContent: this.props.noteDetail.content, }); } render() { return ( &lt;View&gt; &lt;ScrollView&gt; &lt;TextInput style={[styles.noteDetailContent, {height: this.state.height}]} multiline={true} secureTextEntry={false} underlineColorAndroid={&apos;transparent&apos;} value={this.state.noteContent} onChangeText={(noteContent) =&gt; this.setState({noteContent})} onChange={() =&gt; this.onChange.bind(this)} onContentSizeChange={(event) =&gt; this.onContentSizeChange(event)}/&gt; &lt;/ScrollView&gt; &lt;/View&gt; ) } onChange = (event) =&gt; { this.setState({ noteContent: event.nativeEvent.text, height: event.nativeEvent.contentSize.height }); }; onContentSizeChange = (event) =&gt; { this.setState({ height: event.nativeEvent.contentSize.height }); } } const styles = StyleSheet.create({ container: { backgroundColor: &apos;#f5f5f5&apos; }, noteDetailTitle: { backgroundColor: &apos;white&apos;, marginTop: 10, marginBottom: 2, marginLeft: 20, marginRight: 20, height: 35, fontSize: 18, fontWeight: &apos;600&apos; }, noteDetailContent: { backgroundColor: &apos;white&apos;, marginLeft: 20, marginRight: 10, lineHeight: 20, fontSize: 16 } }); export default NoteDetail; 首先创建构造函数 constructor(props) { super(props); this.state = { noteContent: &apos;&apos;, //笔记内容 height: 50, //默认高度 } } 然后设置默认的笔记内容 componentDidMount() { this.setState({ noteContent: this.props.noteDetail.content // 这是从上一个页面传递过来的值 }); } TextInput属性介绍 &lt;TextInput style={[styles.noteDetailContent, {height: this.state.height}]} multiline={true} secureTextEntry={false} underlineColorAndroid={&apos;transparent&apos;} value={this.state.noteContent} onChangeText={(noteContent) =&gt; this.setState({noteContent})} onChange={() =&gt; this.onChange.bind(this)} onContentSizeChange={(event) =&gt; this.onContentSizeChange(event)}/&gt; onChange function 监听方法,文本框内容发生改变回调方法 onChangeText = (text) =&gt; { this.setState({ noteContent: text }) } onChangeText function监听方法，文本框内容发生改变回调方法，该方法主要是监听输入框文字的变化 onChange = (event) =&gt; { this.setState({ noteContent: event.nativeEvent.text }); }; onContentSizeChange function监听方法，当文本框的高度发生变化时回调该方法。当TextInput的高度可变时，调用onLayout方法并将宽高传递给它，并重新绘制该组件。 onContentSizeChange = (event) =&gt; { this.setState({ height: event.nativeEvent.contentSize.height }); } 至此就大功告成了！有什么问题可留言交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native TextInput 属性介绍]]></title>
      <url>%2F2017%2F06%2F18%2FReact%20Native%20TextInput%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[View 支持View的相关属性 autoCapitalize 控制TextInput输入的字符进行切换成大写(可选择参数:’none’, ‘sentences’, ‘words’, ‘characters’) none:不自动切换任何字符成大写 sentences:默认每个句子的首字母变成大写 words:每个单词的首字母变成大写 characters:每个字母全部变成大写 autoCorrect bool 设置拼写自动修正功能 默认为开启(true) autoFocus bool 设置是否默认获取到焦点默认为关闭(false)。该需要componentDidMount方法被调用之后才会获取焦点哦(componentDidMount是React组件被渲染之后React主动回调的方法) defaultValue string 给文本输入设置一个默认初始值。 editable bool 设置文本框是否可以编辑 默认值为true,可以进行编辑 keyboardType 键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的 default numeric 数字键盘 email-address 邮箱地址 maxLength number 可以限制文本输入框最大的输入字符长度 multiline bool 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示) onBlur function 监听方法，文本框失去焦点回调方法 onChange function 监听方法,文本框内容发生改变回调方法 onChangeText function监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容 onEndEditing function监听方法，当文本结束文本输入回调方法 onFocus function 监听方法 文本框获取到焦点回调方法 onLayout function监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height} onSubmitEditing function监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效 placeholder string 当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除 placeholderText Color string 设置默认信息颜色(placeholder) secureTextEntry bool 设置是否为密码安全输入框 ，默认为false style 风格属性 可以参考Text组件风格 value string 输入框中的内容值 以上是一些Android，iOS平台通用的属性，下面根据官网的文档，我这边组要讲解一下适用于Android平台的属性方法 numberOfLines number设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。 textAlign 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’) textAlignVertical 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’) underlineColorAndroid 设置文本输入框下划线的颜色 摘抄自TextInput]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Next 博客搭建资源整理]]></title>
      <url>%2F2017%2F04%2F12%2Fhexo%20%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Next Theme版本5.1.0 hexo博客搭建遇到的问题处理和优化所需的资源 hexo开始搭建 底部Powered By algolia问题 三方服务 Cannot find module ‘hexo-util’ 配置文件属性说明 集成LeanCloud记录次数 hexo next 底部Logo栏(powered by) 添加友言评论]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android MVC和MVP的区别和理解]]></title>
      <url>%2F2017%2F04%2F11%2FAndroid%20MVC%E4%B8%8EMVP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[MVC架构：MVC就是Model-View-Controller，它们的作用是：(数据模型)Model：数据的封装和保存，业务逻辑和实体模型 (视图)View：视图界面，对应于布局文件 (控制器)Controller：业务逻辑，对应于Activity、Fragment等 它们之间的关系如下图所示：View传送指令到Controller,Controller完成业务逻辑后，改变Model的状态，Model将新的数据发送到View，这就是MVC模式的处理逻辑。 MVP架构：MVP是Model-View-Presenter，它们的作用如下： Model：业务逻辑和实体模型，用来操作实际的数据，包含Bean和Model的抽象接口来降低耦合。 View：就是Android中的视图，需要建立一个View的抽象接口View Interface。通过实现View的接口来实现View与Presenter的交互，从而降低耦合。对应于Activity，负责View的绘制与用户交互； Presenter：View和Model的中间枢纽，处理和用户交互的逻辑。 MVP和MVC的对比：MVP架构：View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。 Presenter与View的交互是通过接口来进行的。 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。 MVC架构：View可以与Model直接交互。 Controller是基于行为的，并且可以被多个View共享。 可以负责决定显示哪个View。 通过一个简单的例子来理解MVP模式：View层： /** * ViewInterface * 定义一些通用的view接口 */ public interface LoadDataView { /*** * 耗时操作，加载数据，显示Progress */ void showLoading(); /*** * 隐藏Progress */ void hideLoading(); } /** * 更细小的，用来显示图书细节的View接口 */ public interface LoadBookView extends LoadDataView { void showDetailsView(BookEntity entity); } /*** * Fragment,属于View层，实现了ViewInterface（LoadBookView） */ public class BookDetailFragment extends Fragment implements LoadBookView{ /**图书条形码ISBN号*/ public static final String ISBN = &quot;9787121060748&quot;; /**持Presenter对象*/ private BookDetailsPresenter presenter; @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); initWidget(); presenter = new BookDetailsPresenter(getActivity(), ISBN); // 实例化一个presenter对象 presenter.setView(this); //让Presenter持一个ViewInterface实例（LoadBookView） presenter.loadData(); //告诉Presenter快给我加载Data } @Override public void showDetailsView(BookEntity entity) { //更新UI等操作 } @Override public void showLoading() { rlProgress.setVisibility(View.VISIBLE); } @Override public void hideLoading() { rlProgress.setVisibility(View.GONE); } } 2、Presenter层： public class BookDetailsPresenter { /**持一个Model层的对象，用来从网页接口Rest Api中提取数据*/ private RestApi restApi = null; /**一个ViewInterface对象，用来回调Data给View*/ private LoadBookView loadBookView; private String isbn; public BookDetailsPresenter(Context context, String isbn) { restApi = new RestApiImpl(context); this.isbn =isbn; } public void setView(LoadBookView loadBookView) { this.loadBookView = loadBookView; } public void loadData() { loadBookView.showLoading(); //耗时操作，开个线程异步的加载数据 Thread thread = new Thread(new Runnable() { @Override public void run() { restApi.getBookDetailByIsbn(isbn, bookDetailsCallback); } }); thread.start(); } //匿名内部类，接收bookDetailCallback的回调数据 private RestApi.BookDetailsCallback bookDetailsCallback = new RestApi.BookDetailsCallback() { @Override public void onBookEntityLoaded(BookEntity bookEntity) { notifyDataLoadedSuccessful(bookEntity); BookDetailsPresenter.this.loadBookView.hideLoading(); } @Override public void onError(Exception e) { //异常后的相关处理 } }; /*** * 通知获取数据成功了，赶快通知UI更新吧 */ private void notifyDataLoadedSuccessful(final BookEntity bookEntity) { Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() { @Override public void run() { BookDetailsPresenter.this.loadBookView.showDetailsView(bookEntity); } }); } } 3、Model层： /*** * 整个应用程序需要的数据实体类 */ public class BookEntity { //一些set，get方法 } /** * 一个接口，用来从rest api api获得数据，它的实现在RestApiImpl中 */ public interface RestApi { String API_ISBN_BASE_URL = &quot;https://api.douban.com/v2/book/isbn/&quot;; /*** * 更细小的接口，用来将获取到的数据，回调给它的调用者 */ interface BookDetailsCallback { void onBookEntityLoaded(BookEntity bookEntity); void onError(Exception e); } /** * 从网络获取数据，然后通过bookDetailCallback回调给Presenter * @param isbn * @param bookDetailsCallback */ void getBookDetailByIsbn(final String isbn, final BookDetailsCallback bookDetailsCallback); } 参考文章：http://www.jianshu.com/p/95c9088eef4f http://www.codeceo.com/article/mvp-android.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android观察者模式]]></title>
      <url>%2F2017%2F04%2F11%2FAndroid%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式理解观察者模式 Observer 观察者模式定义了一个一对多的依赖关系，让多个观察者对象同时监听一个主题对象 当这个主题对象改变时，会通知所有的观察者，让他们能够自动的更新自己 观察者模式的组成 抽象主题：把所有的对观察者对象的引用保存在一个集合中，抽象主题提供一个接口，可以注册和移除观察者； 抽象观察者：为所有的观察者定义一个接口，当主题的数据更新时给登记的观察者提供通知； 具体主题：在具体主题内部状态改变时，给所有登记过的观察者发出通知； 具体观察者：实现抽象观察者提供的更新接口，以便本身的状态能够及时更新； 为便于理解可以把主题理解为被观察者 观察者模式的应用抽象观察者/** * 观察者 */ public interface Observer { void update(); } 抽象主题/** * 主题（发布者、被观察者） */ public interface Subject { /** * 注册观察者 */ void registerObserver(Observer observer); /** * 移除观察者 */ void removeObserver(Observer observer); /** * 通知观察者 */ void notifyObservers(); } 显示当前天气的公告牌的数据(具体观察者)public class CurrentConditionsDisplay implements Observer, DisplayElement { private WeatherData weatherData; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 public CurrentConditionsDisplay(WeatherData weatherData) { this.weatherData = weatherData; this.weatherData.registerObserver(this); } @Override public void display() { System.out.println(&quot;当前温度为：&quot; + this.temperature + &quot;℃&quot;); System.out.println(&quot;当前湿度为：&quot; + this.humidity); System.out.println(&quot;当前气压为：&quot; + this.pressure); } @Override public void update() { this.temperature = this.weatherData.getTemperature(); this.humidity = this.weatherData.getHumidity(); this.pressure = this.weatherData.getPressure(); display(); } } 用于获取数据的具体主题(被观察者)public class WeatherData implements Subject { private List&lt;Observer&gt; observers; private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 private List&lt;Float&gt; forecastTemperatures;//未来几天的温度 public WeatherData() { this.observers = new ArrayList&lt;Observer&gt;(); } @Override public void registerObserver(Observer observer) { this.observers.add(observer); } @Override public void removeObserver(Observer observer) { this.observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(); } } public void measurementsChanged() { notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure, List&lt;Float&gt; forecastTemperatures) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; this.forecastTemperatures = forecastTemperatures; measurementsChanged(); } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; } public List&lt;Float&gt; getForecastTemperatures() { return forecastTemperatures; } } 用于公告牌显示的接口(观察者)public interface DisplayElement { void display(); } 公告牌CurrentConditionsDisplay实现了Observer和DisplayElement接口，在他们的构造方法中会调用WeatherData的registerObserver方法将自己注册成观察者，这样被观察者WeatherData就会持有观察者的应用，并将它们保存到一个集合中。当被观察者WeatherData状态发送变化时就会遍历这个集合，循环调用观察者公告牌更新数据的方法。后面如果我们需要增加或者删除公告牌就只需要新增或者删除实现了Observer和DisplayElement接口的公告牌就好了。 参考链接： http://www.cnblogs.com/mengdd/archive/2013/02/07/2908929.html http://www.jianshu.com/p/d55ee6e83d66 ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ionic修改相册插件和监听Android返回]]></title>
      <url>%2F2017%2F04%2F11%2Fionic%E7%9B%91%E5%90%ACAndroid%E8%BF%94%E5%9B%9E%2F</url>
      <content type="text"><![CDATA[ionic混合开发调用Android系统相册，官方的cordova-image-picker插件在直接用的时候会在Android6.0以上的版本由于没有获得相应的存储权限而闪退。 解决方法一： 在原有的cordova插件上面改动，添加了动态授权，我放在了github 用法和原来的相同。 function getImgPicker() { var options = { maximumImagesCount: 1, width: 800, height: 800, quality: 80, title:&apos;&apos;, message:&apos;&apos;, outputType:1 }; window.imagePicker.getPictures(function (results) { vm.userInfo.Url = results[0]; console.log(vm.userInfo.Url); vm.upload(vm.userInfo.Url); }, function (err) { publicMethod.showLoadingNoBackdrop(&apos;调取相册失败&apos;); console.log(angular.toJson(error, true)); }, options); } 解决方法二： 添加一个新的插件，专门获取所需的权限cordova-plugin-android-permissions，下面是用法。 var permissions = cordova.plugins.permissions; permissions.hasPermission(permissions.CAMERA, checkPermissionCallback, null); function checkPermissionCallback(status) { if(!status.hasPermission) { var errorCallback = function() { console.warn(&apos;Camera permission is not turned on&apos;); } permissions.requestPermission( permissions.CAMERA, function(status) { if(!status.hasPermission) errorCallback(); }, errorCallback); } } ionic 监听Android的返回键和双击退出程序(直接上代码) $ionicPlatform.registerBackButtonAction(function (e) { e.preventDefault(); //判断处于哪个页面时双击退出 if ($location.path() == &apos;/tab/home&apos; || $location.path() == &apos;/tab/activity&apos; || $location.path() == &apos;/tab/person&apos; || $location.path() == &apos;/tab/share&apos; || $location.path() == &apos;/tab/study&apos;) { if ($rootScope.backButtonPressedOnceToExit) { ionic.Platform.exitApp(); } else { $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show(&quot;再按一次退出系统&quot;, &quot;short&quot;, &quot;bottom&quot;); $timeout(function () { $rootScope.backButtonPressedOnceToExit = false; }, 2000); } } else if ($location.path() == &apos;/blueprint-list&apos; || $location.path() == &apos;/megagame-list&apos;) { $state.go(&apos;tab.activity&apos;); //此处判断当前所处的View,并返回到tab页 } else if ($ionicHistory.backView()) { $ionicHistory.goBack(); } else { if ($rootScope.backButtonPressedOnceToExit) { ionic.Platform.exitApp(); } else { $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show(&quot;再按一次退出系统&quot;, &quot;short&quot;, &quot;bottom&quot;); $timeout(function () { $rootScope.backButtonPressedOnceToExit = false; }, 2000); } } return false; }, 101);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac跨域]]></title>
      <url>%2F2017%2F04%2F11%2FMac%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[Mac： chrome49以前版本open -a &quot;Google Chrome&quot; --args --disable-web-security chrome49以后版本open -a /Applications/Google\ Chrome.app --args --disable-web-security --user-data-dir Safariopen -a &apos;/Applications/Safari.app&apos; --args --disable-web-security Window： chrome.exe –disable-web-security PS：Mac–&gt;Chrome如果命令行不成功可以安装一个插件Allow-Control-Allow-Origin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ionic固定大小的图片防止变形]]></title>
      <url>%2F2017%2F04%2F11%2FimageCover%2F</url>
      <content type="text"><![CDATA[使用情景：当我们遇到需要固定大小的图片，而又不想让图片变形 这个时候我要应该要想到的是css中的background相关属性 .backImg{ &apos;background-image&apos;: &apos;url(&apos;&apos;)&apos;, &apos;background-size&apos;: &apos;cover&apos;, &apos;background-position&apos;: &apos;center&apos; } //background-size 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 背景图像的某些部分也许无法显示在背景定位区域中。 这样我们就做到了可以让图片局部显示并达到了图片没有变形的效果 下面是AngularJs把它封装为相应的指令 angular.module(&apos;imgTransformModule&apos;, []) .directive(&apos;imgTransform&apos;, function () { return function (scope, element, attrs) { attrs.$observe(&apos;imgTransform&apos;, function (value) { element.css({ &apos;background-image&apos;: &apos;url(&apos; + value + &apos;)&apos;, &apos;background-size&apos;: &apos;cover&apos;, &apos;background-position&apos;: &apos;center&apos; &apos;display&apos;:&apos;inline-block&apos;; }); }); }; }); 调用 &lt;div class=&quot;img-Transform&quot; img-transform=&quot;{{url}}&quot;&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cordova插件开发-Android获取资源Id]]></title>
      <url>%2F2017%2F04%2F10%2FgetResourcesId%2F</url>
      <content type="text"><![CDATA[在制作Cordova插件时不能通过R文件来寻找资源Id，因为R文件是不断变化的，所以我们必须要通过资源名称来获取Id，下面就介绍一下资源id的获取: 使用Resources 类的 getIdentifier方法 通过资源名称虚招布局文件的id private int getResId(String resourceName){ Resources resources = getResources(); int resId = resources.getIdentifier(resourceName,&quot;layout&quot;,getPackageName()); return resId; } 获取字符串id private int getStringId(String stringName){ Resources resources = getResources(); int resId =resources.getIdentifier(stringName,&quot;string&quot;, getPackageName()); return resId; } 获取控件id private int getId(String idName){ Resources resources = getResources(); int resId = resources.getIdentifier(idName, &quot;id&quot;, getPackageName()); return resId; } 获取动画id private int getAnimId(String idName){ Resources resources = getResources(); int resId = resources.getIdentifier(idName, &quot;anim&quot;, getPackageName()); return resId; } 作为一个Android开发者来说，也许你已经发现上面代码的不同点了，就是getIdentifier()里面的第二个参数的不同，我们可以通过替换这个参数来达到大部分的寻找资源id（example：id, string, anim, attr, drawable, layout, color, menu, styles…） 通过Java的强大的反射机制获取资源id 通过反射获取一个资源id public int getAttrId(String attrName) { try { Class&lt;?&gt; loadClass = mContext.getClassLoader().loadClass(mContext.getPackageName() + &quot;.R&quot;); Class&lt;?&gt;[] classes = loadClass.getClasses(); for (int i = 0; i &lt; classes.length; i++) { if (classes[i].getName().equals(mContext.getPackageName() + &quot;.R$attr&quot;)) { Field field = classes[i].getField(attrName); int attrId = field.getInt(null); return attrId; } } } catch (Exception e) { e.printStackTrace(); } return 0; } 首先使用反射能达到上面的获取一个id的情况，但是比较麻烦，当需要返回一个数组我们就不得不使用这种方法了 private int[] getStyleableArryId(String styleableName){ try { Class&lt;?&gt; loadClass = getContext().getClassLoader().loadClass(getContext().getPackageName() + &quot;.R&quot;); Class&lt;?&gt;[] classes = loadClass.getClasses(); for(int i=0 ;i&lt;classes.length ;i++){ Class&lt;?&gt; resClass = classes[i]; if(resClass.getName().equals(getContext().getPackageName() + &quot;.R$styleable&quot;)){ Field[] fields = resClass.getFields(); for (int j = 0; j &lt; fields.length; j++) { if(fields[j].getName().equals(styleableName)){ int[] styleable = (int[]) fields[j].get(null); return styleable; } } } } } catch (Exception e) { e.printStackTrace(); } return null; } 但是在设置styleable的资源id的时候，如果你是自定义的View，如果需要引入自定义的attr,比如这样：public WheelVerticalView(Context context, final AttributeSet attrs) { this(context, attrs, R.attr.abstractWheelViewStyle); this(context, attrs, 0); } 那么你是不能通过上面的方法，来获取资源文件的，因为这是一个构造器，你只能另找它法了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 微信sdk登录和分享]]></title>
      <url>%2F2017%2F04%2F10%2FweChat-login%2F</url>
      <content type="text"><![CDATA[准备材料： 微信开发者账号 注册你的APP libammsdk.jar包 debug.keystore文件 准备工作 申请你的APPID 导入libammsdk.jar包 在AndroidManifest.xml中设置权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 注册APP到微信 private static final String App_Id = &quot;你注册的APP_ID&quot;; private IWXAPI api; public void registerToWX(){ api = WXAPIFactory.createWXAPI(this, App_Id, true); api.registerApp(App_ID); } 分享： 分享(以分享图片为例) 直接触发分享图片按钮的点击事件 findViewById(R.id.send_img).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.send_img); WXImageObject imgObj = new WXImageObject(bmp); WXMediaMessage msg = new WXMediaMessage(); msg.mediaObject = imgObj; Bitmap thumbBmp = Bitmap.createScaledBitmap(bmp, 150, 150, true); bmp.recycle(); msg.thumbData = Util.bmpToByteArray(thumbBmp, true); SendMessageToWX.Req req = new SendMessageToWX.Req(); req.transaction = buildTransaction(&quot;img&quot;); req.message = msg; req.scene = SendMessageToWX.Req.WXSceneTimeline; SendMessageToWX.Req.WXSceneSession; api.sendReq(req); finish(); } }); 其中req.scene表示分享选择分别代表分享到朋友圈和会话框 Util是一个图片处理的类 登录 登录需要重新APP到微信，需要触发回调,下面直接上代码： package com.lht.pan_android.wxapi; import org.apache.http.Header; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import com.alibaba.fastjson.JSON; import com.lht.pan_android.HttpUtil; import com.lht.pan_android.MainActivity; import com.lht.pan_android.R; import com.lht.pan_android.WeChatCodeBean; import com.loopj.android.http.AsyncHttpResponseHandler; import com.tencent.mm.sdk.modelbase.BaseReq; import com.tencent.mm.sdk.modelbase.BaseResp; import com.tencent.mm.sdk.modelmsg.SendAuth; import com.tencent.mm.sdk.openapi.IWXAPI; import com.tencent.mm.sdk.openapi.IWXAPIEventHandler; import com.tencent.mm.sdk.openapi.WXAPIFactory; public class WXEntryActivity extends Activity implements IWXAPIEventHandler { private static final String TAG = &quot;wechat&quot;; private static final String APP_ID = &quot;你的APP_Id&quot;; private static final String APP_SECRET = &quot;你的APP_secret&quot;; private Button registerBtn; private IWXAPI api; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.entry); registerBtn = (Button) findViewById(R.id.reg_btn); tv = (TextView) findViewById(R.id.log); api = WXAPIFactory.createWXAPI(this, APP_ID, true); registerBtn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { loginWithWeixin(); } }); api.handleIntent(getIntent(), this); } //登录信息 private void loginWithWeixin() { if (api == null) { api = WXAPIFactory.createWXAPI(this, APP_ID, false); } if (!api.isWXAppInstalled()) { Toast.makeText(this, &quot;没有安装微信&quot;, Toast.LENGTH_SHORT).show(); return; } api.registerApp(APP_ID); SendAuth.Req req = new SendAuth.Req(); req.scope = &quot;snsapi_userinfo&quot;; req.state = &quot;com.lht.bridge.session&quot;; api.sendReq(req); } @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this); } //实现了IWXAPIEventHandler @Override public void onReq(BaseReq req) { } //实现了IWXAPIEventHandler @Override public void onResp(BaseResp resp) { code_code = ((SendAuth.Resp) resp).code; String result = null; switch (resp.errCode) { case BaseResp.ErrCode.ERR_OK: result = &quot;发送成功&quot;; //此处进行数据请求，请求用户信息 Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_USER_CANCEL: result = &quot;发送取消&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; case BaseResp.ErrCode.ERR_AUTH_DENIED: result = &quot;发送被拒绝&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; default: result = &quot;发送返回&quot;; Toast.makeText(this, result, Toast.LENGTH_LONG).show(); finish(); break; } Toast.makeText(this, result, Toast.LENGTH_LONG).show(); } } 实现IWXAPIEventHandler接口，微信发送的请求将回调到onReq方法，发送到微信请求的响应结果将回调到onResp方法 在WXEntryActivity中将接收到的intent及实现了IWXAPIEventHandler接口的对象传递给IWXAPI接口的handleIntent方法 在Androidmanifest.xml中注册： &lt;activity android:name = &quot;.wxapi.WXEntryActivity&quot; android:exported = &quot;true&quot;/&gt; 请求用户信息： 微信需要先获取到code，再根据code获取access_token，根据access_token获取openId，最后根据access_token和openId获取用户信息 到此微信登录和分享的流程基本走通了，但是还有许多需要注意的问题 1、最最最重要的一点是登录需要单独写一个包,据说这样登录才能走微信自己的一套机制 格式为：包名.wxapi 类名：WXEntryActivity.java 2、导入的jar包问题，jar包导入的不对就可能导致获取code这一步出现问题，微信的jar包分为老版本和新版本，新版本的可以直接获取access_token，但是官网并没有说明怎么通过access_token获取用户信息，老版本的jar包是可以获取code的，然后自己根据code自己写网络请求(你没有看错，就是自己写网络请求)； 3、程序运行时一定要保证你的签名正确，如果需要更换你的key，windows下需要更换sdk/.android/debug.keystore以正确替换你的key 目前能想到的就这些了，有什么问题欢迎指出，最后吐槽一下微信登录竟然收费、微信的文档就呵呵了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native探索与设计(一)]]></title>
      <url>%2F2017%2F04%2F09%2FReact%20Native%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%AE%BE%E8%AE%A1(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[React Native探索与设计(一) 1. React Native有什么优点 跨平台 动态更新 代码复用 最大的优势就是既有Web的热更新优势，又有接近Native的性能 2. React Native VS Hybrid 性能： Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少。 用户体验：React Native 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。 3. React Native VS Weex Weex bug比较多 社区、文档弱，GitHub Issue 基本是中文:这就意味着Weex并没有国际化，Weex还有很长的路要走 4. React Native 劣势 学习成本：而 React Native 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大(ES6的箭头函数、展开运算符) 首次加载耗时：React Native 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新(在发布 client 时内置一个写好的 js 文件在本地作缓存用) 5. React Native 运行机制 在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件 读取 JavaScript 源码。JavaScript 加载进内存, JSX 代码已经被转化成原生的 JavaScript 代码 初始化模块信息。通过initModulesWithDispatchGroup()找到所有需要暴露给JavaScript的类 初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象 生成模块列表并写入 JavaScript 端 执行 JavaScript 源码 React Native运行机制详解 6. React Native 开发环境搭建 IDE：Nuclide、Deco、Webstorm、Sublime Text 环境搭建 一、安装Homebrew。Homebrew是Mac OSX的包管理器，我们需要通过Homebrew安装开发React Native的相关软件包。 二、安装Node.js。 $brew install node 三、安装watchman。watchman是Facebook用于监视JavaScript文件改动的开源项目。 $brew install watchman 四、安装flow。flow是Facebook开源的一个JavaScript静态类型检查器，用于发现JavaScript程序中的类型错误。 $brew install flow 五、安装react-native-cli。react-native-cli是React Native的命令行工具，安装react-native-cli后我们就能够通过react-native相关命令管理ReactNative工程。 $npm install -g react-native-cli 目录结构 android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行 node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成； js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自动生效。]]></content>
    </entry>

    
  
  
</search>
