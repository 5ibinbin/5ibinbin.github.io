<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode：950.按递增顺序显示卡牌]]></title>
    <url>%2F2019%2F07%2F04%2FLeetCode%2F950%2F</url>
    <content type="text"><![CDATA[题目 按递增顺序显示卡牌 描述 牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。现在，重复执行以下步骤，直到显示所有卡牌为止：从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。返回能以递增顺序显示卡牌的牌组顺序。答案中的第一张牌被认为处于牌堆顶部。 示例 输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 过程演示 我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。我们展示 13，然后将 17 移到底部。牌组现在是 [17]。我们显示 17。由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。 讲解 题目理解：整个抽牌过程我们可以理解为：牌组顶部抽一张，将下一张放到牌组底部。我们可以先将数组排序，然后倒推整个过程：将牌组底部的牌弹出并放到牌组顶部，再在牌组顶部放一张牌 解题思路 1234567891011var deckRevealedIncreasing = function(deck) &#123; deck.sort((x, y) =&gt; x - y); //排序 let result = []; while (deck.length &gt; 0) &#123; if (result.length &gt; 0) &#123; result.unshift(result.pop()) //先将元素从尾部到首部 &#125; result.unshift(deck.pop()) //再将元素放到首部 &#125; return result;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：11.盛最多水的容器]]></title>
    <url>%2F2019%2F06%2F16%2FLeetCode%2F11%2F</url>
    <content type="text"><![CDATA[题目 盛最多水的容器 描述 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 输入: [1,8,6,2,5,4,8,3,7]输出: 49 讲解 题目理解：如上图，垂直的两条线段将会与坐标轴构成一个矩形区域，矩形面积越大代表容器可以容纳更多的水，所以此题可理解为求矩形区域面积的最大值 解题思路 方法一：暴力求解可以通过两次for循环求出所有的可能出现的情况，找出最大值 1234567891011var maxArea = function(height) &#123; let len = height.length; let maxArea = 0; if(len &lt; 2) return; // 判断数组长度不小于2 for(let i = 0; i &lt; len; i++)&#123; for (let j = i+1; j &lt; len; j++)&#123; maxArea = Math.max(maxArea, (j-i) * Math.min(height[i], height[j])) &#125; &#125; return maxArea&#125;; 复杂度分析 时间复杂度：O(n2)，计算所有的n(n-1)/2种情况 空间复杂度：O(1) 方法一：双指针法将两个指针放到数组的开始和结尾，使用maxArea来存储矩形面积。每循环一次都会更新maxArea，并移动较小数值所对应的指针(为什么移动较小数值的？看这个矩形，在宽度一定(两个指针移动之后的宽度都是-1，所以宽度一定)的情况下，是不是保留高度高的情况下才有可能使面积更大)，最后就得出了最大的面积 12345678910111213141516var maxArea = function(height) &#123; let len = height.length; let maxArea = 0; let left = 0; let right = len - 1; if(len &lt; 2) return; while(left &lt; right)&#123; maxArea = Math.max(maxArea, (right - left)*Math.min(height[left], height[right])); if (height[left] &lt;= height[right])&#123; left++ &#125; else &#123; right-- &#125; &#125; return maxArea&#125;; 复杂度分析 时间复杂度：O(n)，只需要扫描一次 空间复杂度：O(1)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包]]></title>
    <url>%2F2018%2F01%2F23%2FJavaScript%2FJavaScript%20%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文转载自前端学习指南的这篇文章(写的很清晰易懂，实在不忍心修改) 《javascript高级程序设计》（第三版）第7章第2节： 闭包是指有权访问另一个函数作用域中的变量函数 《javascript权威指南》(第六版)第8章第6节： 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。 本文作者的理解(当然我的理解和本文作者的理解是一样的) 「函数」和「函数内部能访问到的变量」(也叫环境)的总和，就是一个闭包。 请用自己的话简述 什么是「闭包」 「闭包」的作用是什么 首先来简述什么是闭包1234var local = '变量';function foo()&#123; console.log(local);&#125; ① 假如上面三行代码在一个立即执行函数中。② 三行代码中，有一个局部变量local，有一个函数foo，foo里面可以访问到local变量。这就是闭包。 有的同学就疑惑了，闭包这么简单么？我听说闭包是需要函数套函数，然后 return 一个函数的呀！比如这样： 12345678910function foo()&#123; var local = 1 function bar()&#123; local++ return local &#125; return bar&#125;var func = foo()func() 这里面确实有闭包，local 变量和 bar 函数就组成了一个闭包（Closure）。 为什么要函数套函数呢？ 是因为需要局部变量，所以才把local放在一个函数里，如果不把local放在一个函数里，local就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。 这也是为什么我上面要说「运行在一个立即执行函数中」。有些人看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。所以函数套函数只是为了造出一个局部变量，跟闭包无关。 为什么要 return bar 呢？ 因为如果不 return，你就无法使用这个闭包。把return bar改成window.bar = bar也是一样的，只要让外面可以访问到这个bar函数就行了。 所以return bar只是为了bar能被使用，也跟闭包无关。 闭包的作用 闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。 假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量： 1window.lives = 30 // 还有三十条命 ① 这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？② 用局部变量。但是用局部变量别人又访问不到，怎么办呢？③ 暴露一个访问器（函数），让别人可以「间接访问」。 代码如下： 123456789function()&#123; var lives = 50 window.add = function()&#123; lives += 1 &#125; window.minus = function()&#123; lives -= 1 &#125;&#125;() 那么在其他的JS文件，就可以使用window.add()来涨命，使用 window.minus()来让角色掉一条命。这里会形成两个闭包，lives+window.add、lives+window.minus 我们来重新审视下闭包的代码： 1234var local = '变量';function foo()&#123; console.log(local);&#125; 第一句是变量声明，第二句是函数声明，第三句是 console.log。每一句我都学过，为什么合起来我就看不出来是闭包？ 我告诉你答案，你根本不需要知道闭包这个概念，一样可以使用闭包！ 闭包是JS函数作用域的副产品。 换句话说，正是由于JS的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是JS故意要使用闭包。很多编程语言也支持闭包，另外有一些语言则不支持闭包。只要你懂了JS的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！ 所谓闭包的作用 如果我们在写代码时，根本就不知道闭包，只是按照自己的意图写，最后，发现满足了闭包的定义。那么请问，这算是闭包的作用吗？ 关于闭包的谣言 闭包会造成内存泄露？ 错。 说这话的人根本不知道什么是内存泄露。内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。 闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？ 这个谣言是如何来的？ 因为IE。IE有bug，IE在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是IE的问题，不是闭包的问题。参见司徒正美的这篇文章。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 链表的实现]]></title>
    <url>%2F2018%2F01%2F19%2FStructure%2FJavaScript%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言 我们知道数组是一个查找很迅速的数据结构而链表的优势就在于插入和删除很快的一种数据结构，此次将通过实例来实现链表的数据结构。 链表API append(element): 向列表尾部添加一个新的项 insert(position, element): 向列表的特定位置插入一个新项 remove(element): 从列表中移除 removeAt(position): 从列表的特定位置移除一项 isEmpty(): 判断列表是否为空 size(): 返回链表的元素个数 链表实现 类似这样 123456789101112function LinkedList()&#123; var length = 0; var head = null; var Node = function(element)&#123; this.element = element; this.next = null; &#125; // 具体方法 ··· ··· ···&#125; 首先新建了LinkList的数据结构，初始化了链表的长度为0，头结点(head)为null，并通过Node类声明了每个节点的数据结构(元素和指针组成)，之后的具体实现我们下面依次介绍。 append 1234567891011121314this.append = function(element)&#123; var node = new Node(element); var current = null; if (head === null)&#123; head = node; &#125; else &#123; current = head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125; length++;&#125; 首先初始化节点，判断当前链表是否为空，为空则为head节点，否则遍历链表知道找到最后一个节点，并把当前节点放到最后位置，长度(length)+ 1 insert 12345678910111213141516171819202122this.insert = function(position, element)&#123; if (position &gt;=0 &amp;&amp; position &lt;= length)&#123; var node = new Node(element); var current = head; var previous = null; var index = 0; if (position === 0)&#123; node.next = head; head = node; &#125; else &#123; while (index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125; return false;&#125; ① 判断需要插入的位置，防止越界② position === 0，插入头结点③ position !== 0，遍历节点，找到要插入的位置和前一个位置，然后再插入其中 removeAt 1234567891011121314151617181920this.removeAt = function(position)&#123; if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; var current = head; var previous = null; var index = 0; if (position === 0)&#123; head = current.next; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; current = current.next; previous.next = current; &#125; length--; return current.element; &#125; return null;&#125; 和插入方法类似，判断需要删除的位置，防止越界position === 0，删除头结点(将头结点的下一节点指向头结点)position !== 0，遍历节点，找到要删除的位置，将前一节点的下一节点指向当前节点的下一节点。如下图： remove 上一步我们已经实现removeAt，实现remove可以借助removeAt，如下所示：123456789101112this.indexOf = function(element)&#123; var current = head, var index = -1; while(current)&#123; if (element === current.element)&#123; return index; &#125; index++; current = current.next; &#125; return index;&#125; 首先找到我们要删除的元素的位置(index) 1234this.remove = function(element)&#123; var index = this.indexOf(element); return this.removeAt(index);&#125; 然后借助removeAt删除元素 isEmpty 123this.isEmpty = function()&#123; return length === 0;&#125; 直接判断当前长度是否为0 size 123this.size = function()&#123; return length;&#125; 直接返回length 本次内容到此结束，我们下次再见！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 预处理机制]]></title>
    <url>%2F2018%2F01%2F17%2FJavaScript%2FJavaScript%20%E9%A2%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript是一种描述型脚本语言，它不同于java或C#等编译性语言,它不需要进行编译成中间语言,而是由浏览器进行动态地解析与执行 代码块 JS是按照代码块来进行编译和执行的，代码块间相互独立，但变量和方法共享(ES5)，ES6增加了块级作用域，故块级的变量和方法已不满足共享。 12345678//方式一：&lt;script&gt; console.log('script代码块');&lt;/script&gt;//方式二：&#123; console.log('&#123;&#125; 代码块');&#125; 函数定义 JavaScript中函数定义一般包括：匿名函数(赋值式函数)和 声明式函数12345678// 声明式函数function Func()&#123; // 函数体&#125;// 赋值式函数let Func = function()&#123; // 函数体&#125; 在页面加载过程中如果遇到声明式函数会对它进行预处理(预编译)，当遇到赋值式函数时只是将函数赋给变量。对于变量也只是将变量进行声明，并未进行初始化及赋值操作。 样例说明 1234Func(); // 输出：声明式函数function Func()&#123; console.log('声明式函数');&#125; 由此可见声明式函数Func已经进行了预处理，我们可以直接进行调用。 1234Func();var Func = function()&#123; console.log('赋值式函数');&#125; 在本例中会报Func is not a function，程序并没有对赋值式函数Func()进行预处理，这导致我们的并没有发现这个方法。这也是我们推荐使用显示的方式声明函数的原因。 同理，我们的变量也会遇到同样的问题1console.log(str); 此时会报str is not defined，我们根本就没有声明这个变量。接着看下面例子 12console.log(str);var str = 'string'; 此时程序会输出undefined，这是因为程序在预处理过程中对变量str进行了声明，但是没有进行初始化或赋值操作；如果将程序上下交换一下就会正常执行。 body body的onload函数与body内部函数的执行123456789101112&lt;script type="text/javascript"&gt; console.log("first"); function Func()&#123; console.log("third"); &#125; &lt;/script&gt; &lt;body onload="Func()"&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; console.log("second"); &lt;/script&gt; 根据HTML文档流的执行顺序，需要在页面元素渲染前执行的js代码应该放在&lt;body&gt;前面的&lt;script&gt;代码块中，而需要在页面元素加载完后的js放在&lt;/body&gt;元素后面，body标签的onload事件是在最后执行的。 执行期 下一篇我们将通过for循环与setTimeout来说明程序的同步执行问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 同步异步的前世今生]]></title>
    <url>%2F2018%2F01%2F15%2FJavaScript%2FJavaScript%20%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[写在前面的话 setTimeout是我们学习JavaScript基础都必须面对的问题，也许当时你搞懂了，但是过一段时间就又忘记了。最近事情不多，我将梳理出for + setTimeout相关的知识点，以及使用Promise、async/await来加深对异步、同步的理解 setTimeout 直接进入正题：12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 也许我们希望输出的是 1,2,3,4,5，但实际情况是我们输出了5,5,5,5,5，这到底是为什么呢？由JS的运行机制中我们得知：当线程中没有任何同步代码的前提下才会执行异步代码。我们的for循环时同步的，但是setTimeout是异步的，由此就造成了输出5,5,5,5,5这种情况。 通过一顿胡乱分析我们得出假设：只要保证里面的也变成同步的是不是就可以了呢？方式① 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i*1000)&#125; 这里使用的是最简单的方式：动态的改变延迟的时间。因为for循环时同步的，而setTimeout是异步的，所以会先把for循环执行完毕，然后再执行内部的setTimeout，所以输出结果为每隔1秒输出一个5 方式② 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(j)&#123; setTimeout(function ()&#123; console.log(j); &#125;,1000); &#125;)(i); &#125; 我们通过设置一个立即执行函数(IIFE)，这样就能保证里面和外面的是同步执行的。 方式③ 123456789function output(i)&#123; setTimeout(function()&#123; console.log(i); &#125;, 1000)&#125;for(var i = 0; i &lt; 5; i++)&#123; output(i);&#125; 这里其实和第一种方法类似，只不过我们把这个函数单独拿出来，并把index值当做函数的参数来传递 方式④ 12345for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, 1000)&#125; let是ES6语法，for循环代码块构成一个作用域，里面的内容引用了上层作用域的变量 i，并最终形成五个闭包，而for使用var时，还是ES5的写法，for代码块没有形成作用域，所以里面的function不构成闭包。同理我们的方式②和方式③都形成了闭包函数。 如果我们需要最后一个延迟5秒，其余的都是延迟1秒，我们就可以用到ES6的语法–Promise，下面我们用Promise实现这一情况方式⑤ 123456789101112131415const task = [];const output = (i) =&gt; new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; console.log(i); resolve(); &#125;, i*1000)&#125;)for (var i = 0; i&lt;5; i++)&#123; task.push(output(i));&#125;Promise.all(task).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 5000);&#125;) 这里采用了Promise解决异步的方式，在ES7中解决异步还有async/await的方式 方式⑥ 1234567891011121314const sleep = (timeount) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeount);&#125;);Func = async () =&gt; &#123; for(var i = 0; i&lt;5; i++)&#123; await sleep(1000); console.log(i); &#125; await sleep(5000); console.log(i);&#125;this.Func(); async 表示这是一个async函数，await只能用在这个函数里面；await 表示在这里等待promise返回结果了，再继续执行；await 后面跟着的应该是一个promise对象，否则没有同步效果]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>同步/异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 哈希表的实现]]></title>
    <url>%2F2018%2F01%2F11%2FStructure%2FJavaScript%20%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表 通过把关键码值映射到表中一个位置来访问记录，根据Key value而直接进行访问的数据结构。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 对比 数组：查找容易，插入和删除较难链表：查找较难，插入和删除比较容易哈希表：把上述的两种优势有效的结合起来 简单实现 目标方法① put(key, value) 向哈希表中增加一个元素② remove(key) 从哈希表中删除一个元素③ get(key) 查找特定元素 创建HashTable123function HashTable()&#123; let table = [];&#125; 使用数组来表示哈希表 创建HashCode散列函数1234567let HashCode = function(key)&#123; let hash = 0; for (let i = 0; i&lt; key.length; i++)&#123; hash += key.charCodeAt(i); &#125; return hash%37;&#125; 使用HashCode()确定每个key所对应的ASCII值，把它当做hash值。这个函数就是我们所说的散列函数。 put1234this.put = function(key, value)&#123; let position = HashCode(key); table[position] = value;&#125; 先得到hash值，然后把相应的value放入对应的位置 get123this.get = function(key)&#123; return table[HashCode(key)];&#125; 根据hash值取value remove123this.remove = function(key)&#123; table[HashCode(key)] = undefined;&#125; 简单粗暴的置为undefined 哈希冲突 提到哈希表我们必然要解决的就是哈希冲突。本文将介绍两种方式：分离链接和线性探查分离链接 分离链接要求我们为哈希表的每一个位置创建一个链表并将key值相同的元素存储在链表中，这是解决冲突最简单的方法，但是需要额外的存储空间 对于这种结构我们需要重写put、 get、 remove在HashTable内部定义一个ValuePair类 1234567let ValuePair = function(key, value)&#123; this.key = key; this.value = value; this.toString = function()&#123; return '['+ this.key + ' - ' this.value ']' &#125;&#125; 用这个类来表示要新建的LinkedList实例 put 1234567this.put = function(key, value)&#123; let position = HashCode(key); if (table[position] === undefined)&#123; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value));&#125; 首先获取HashCode(哈希值)，然后判断哈希表中对应的位置是否不存在，若是则在当前位置创建一个链表，否则直接将key-value放入到链表中。其中append使我们之前在链表结构中实现的方法 get 123456789101112131415161718this.get = function(key)&#123; let position = HashCode(key); if (table[position] !== undefined)&#123; let current = table[position].getHead(); // 实际查找的是1~~(n-2) while(current.next)&#123; if (current.element.key === key)&#123; return current.element.value; &#125; current = current.next; &#125; // 判断第一个和最后一个节点为要找的值的情况 if (current.element.key = key)&#123; return current.element.value; &#125; &#125; return undefined;&#125; 首先判断当前位置是否有值，若无返回undefined，否则获取当前节点，判断当前节点的下一节点的key是否相等，相等则返回值。最后我们需要判断一下首尾为我们要找的值的情况。 remove 12345678910111213141516171819202122232425this.remove = function(key)&#123; let position = HashCode(key); if (table[position] !== undefined)&#123; let current = table[position].getHead(); while(current.next)&#123; if (current.element.key === key)&#123; table[position].remove(current.element); if (table[position].isEmpty())&#123; table[position] = undefined; &#125; return true; &#125; current = current.next; &#125; // 第一个和最后一个的情况 if (current.element.key === key)&#123; table[position].remove(current.element); if (table[position].isEmpty())&#123; table[position] = undefined; &#125; return true; &#125; &#125; return false;&#125; 和get类似，获取哈希值，判断当前哈希表是否存在对应的哈希值。循环遍历直到找到需要remove的key，删除之，最后判断一下，删除之后的该位置的链表是否为空，over第7,17行的 remove 为前文的数据链表的方法 线性探查 线性探查：如果想往表中插入一个值，如果索引为index的已被占据，就自动往下一位置查找，如果index+1位置也被占用，则继续查找下一位置，以此类推。 同样我们需要实现get、put、removeput 123456789101112this.put = function(key, value)&#123; let position = HashCode(key); if (table[position] === undefined)&#123; table[position] = new ValuePair(key, value); &#125; else &#123; let index = ++position; while(table[index] !== undefined)&#123; index++; &#125; table[index] = new ValuePair(key, value); &#125;&#125; 首先判断当前哈希值HashCode对应的位置是否为空为空则直接插入当前位置不为空我们需要遍历找到下一个不为空的位置并将value插入其中 get 123456789101112131415this.get = function(key)&#123; let position = HashCode(key); if (table[position] !== undefined)&#123; if (table[position].key === key)&#123; return table[position].value &#125; else &#123; let index = ++position; while (table[index] === undefined || table[index].key !== key)&#123; index++; &#125; return table[index].value &#125; &#125; return undefined;&#125; 首先判断当前哈希值HashCode对应的位置是否为空为空则直接返回undefined不为空我们需要继续判断 当前位置所对应的key，是否和所要查的key相等，相等则返回对应的value，不相等则找到对应的位置并返回 remove 123456789101112131415this.remove = function(key)&#123; let position = HashCode(key); if (table[position] !== undefined)&#123; if (table[position].key === key)&#123; table[position] = undefined; &#125; else &#123; let index = ++position; while (table[index] === undefined || table[index].key !== key)&#123; index++; &#125; table[index] = undefined; &#125; &#125; return false;&#125; remove 和 get 相似，只不过一个返回值，一个把值置为空；]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2018%2F01%2F09%2FStructure%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[序言：本文将带你掌握二叉树、二叉搜索树以及他们的构建、元素的查找和删除 二叉树 满足树中的节点最多只能有两个的就称为二叉树 二叉搜索树(BTS) 在满足二叉树的基础上且满足左侧节点的值比父节点小，右侧节点的值比左侧节点大的称为二叉搜索树。 二叉树特性 由于这种树形的数据结构使得其无论是增删还是查找，算法的时间复杂度都为O(h)，h为数的高度。因此二叉树应尽可能的使左右平衡。 二叉搜索树的构建 12345678function BinarySearchTree() &#123; let Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; let root = null;&#125; 创建BinarySearchTree类，声明每一个节点的数据结构，并将初始的根节点置为null(行7) 二叉搜索树的插入(insert) 12345678this.insert = function(key)&#123; let newNode = new Node(key); if (root === null)&#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125;&#125; ① 创建Node实例来生成一个新的节点行2② 判断根节点是否为null，若是则新建节点为根节点，否则插入节点 123456789101112131415let insertNode = function(node, newNode)&#123; if (newNode.key &lt; node.key)&#123; if (node.left === null)&#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null)&#123; node.right = newNode &#125; else &#123; insertNode(node.right, newNode); &#125; &#125;&#125; 树非空情况下，先判断新节点是否小于当前节点(局部根节点)，若小于需要判断当前节点的左节点是否为空，若为空则将当前节点的左节点赋值为新节点，否则继续递归调用insertNode方法。若新节点大于当前节点的情况和小于的类似。 搜索最大值最小值 我们知道二叉搜索树的左节点小于根节点小于右节点，我们可以根据这个特性来求得最大值最小值，方法如下： 123456789this.minNode = function()&#123; if (root)&#123; while(root &amp;&amp; root.left !== null)&#123; root = root.left; &#125; return root.key; &#125; return null;&#125; 123456789this.maxNode = function()&#123; if (root)&#123; while(root &amp;&amp; root.right !== null)&#123; root = root.right; &#125; return root.key; &#125; return null;&#125; 查找特定的值 123456789101112this.search = function(root, key)&#123; if (root === null)&#123; return false; &#125; if (key &lt; root.key)&#123; return search(root.left, key); &#125; else if (key &gt; root.key)&#123; return search(root.right, key); &#125; else if (key === root.key)&#123; return true; &#125;&#125; 依然使用了递归的思想。如果目标值比当前节点小则继续在左侧子树上搜索，比当前节点大则在右侧子树搜索直到找到目标值。 遍历二叉树 中序遍历(第二个遍历父节点) 123456789101112this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); &#125;;let inOrderTraverse = function(node, callback)&#123; if (node !== null)&#123; inOrderTraverse(node.left, callback); callback(node.key); inOrderTraverse(node.right, callback); &#125;&#125;// callback 回调函数function printNode(key)&#123; console.log(key);&#125; 中序遍历顾名思义就是先遍历左侧节点然后是中间父节点最后右侧节点。采用递归的思路对二叉树进行遍历。 先序遍历(先遍历父节点) 123456789101112this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback);&#125;let preOrderTraverseNode = function(node, callback)&#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback);&#125;// 回调函数function printNode(key)&#123; console.log(key);&#125; 先序遍历就是先遍历父节点然后是左侧节点最后是右侧节点，同样采用的是递归思路对二叉树进行遍历。 后序遍历(最后遍历父节点) 123456789101112this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;let postOrderTraverseNode = function(node, callback)&#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key);&#125;// 回调函数function printNode(key)&#123; console.log(key);&#125; 后序遍历就是先遍历左节点然后是右节点最后遍历父节点，同样采用递归思路对二叉树进行遍历。 删除节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344this.remove = function(key)&#123; root = removeNode(root, key);&#125;let removeNode = function(node, key)&#123; if (node === null)&#123; return null; &#125; if (key &lt; node.key)&#123; node.left = removeNode(node.left, key); return node; &#125; else if (key &gt; node.key)&#123; node.right = removeNode(node.right, key); return node; &#125; else &#123; // 第一种情况--一个叶子节点 if (node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; // 第二种情况--一个只有一个子节点的节点 if (node.left === null)&#123; node = node.right; return node; &#125; else if (node.right === null)&#123; node = node.left; return node; &#125; // 第三种情况--一个有两个子节点的节点 let minNode = findMinNode(node.right); node.key = minNode.key; node.right = removeNode(node.right, minNode); return node; &#125;&#125;// 找到右侧的最小节点let findMinNode = function(node)&#123; if (node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node; &#125;&#125; 要想移除节点，首先需要找到节点node.key === key，移除节点分三种情况：① 只有一个叶子节点，我们只需要把节点置空就可以了② 只有一个子节点的节点，需要把它的子节点覆盖当前节点③ 有两个子节点，首先调用findMinNode找到当前节点的右子节点内的最小节点，然后将这个最小节点赋值给当前节点(把要删除的节点给覆盖删除)，最后再把之前找到的最小节点从原来的位置删除。 关于第三种情况看一看下图以加深理解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序查找和二分查找]]></title>
    <url>%2F2018%2F01%2F08%2FAlgorithm%2F%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[顺序查找 说明：顺序查找适用于数据存储形式为顺序存储或链接存储的线性表 算法思想 顺序查找也是线性查找，从数据的一端开始依次查找每一条数据元素并与目标值进行比较。如果相等则找到目标值，否则继续向下查找。 复杂度分析 算法平均执行次数为n/2，则算法的复杂度为O(n) 代码实现 12345678function sequenceSearch(arr, targetValue)&#123; for (let i = 0; i &lt; arr.length; i++)&#123; if (arr[i] === targetValue)&#123; return i; &#125; &#125; return -1;&#125; 二分查找 说明：二分查找适用于已排序的数据 算法思想 二分查找也成为折半查找，将目标值与已排序数据中间值比较，若等于中间值则查找成功；若小于/大于中间值则对左/右侧数据再进行二分查找，依次类推，直到找到目标值。 复杂度分析 最坏情况需要执行log(n+1)，则算法的复杂度为O(logn) 代码实现 1234567891011121314151617function BinarySearch(arr, targetValue)&#123; let low = 0; let high = arr.length - 1; while(low &lt; high)&#123; let middle = Math.floor((low+high)/2); if (arr[middle] &lt; targetValue)&#123; low = middle + 1; &#125; if (arr[middle] === targetValue)&#123; return middle; &#125; if (arr[middle] &gt; targetValue)&#123; high = middle - 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F01%2F07%2FAlgorithm%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 和归并排序一样，快速排序也采用分治的思想 ① 先从数组中取出一个数作为基准数② 分区过程 – 将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边③ 再对左右区间重复第二步，直到各区间只有一个数 复杂度 快排的平均时间复杂度为O(nlogn)，空间复杂度为O(logn)，快速排序是不稳定的，但每次都能确定一个元素所在序列中的最终位置，复杂度与初始序列(基准值)有关 代码实现 12345678function quickSort(arr, indexLeft, indexRight)&#123; if (indexLeft &gt;= indexRight)&#123; return; &#125; let index = position(arr, indexLeft, indexRight); quickSort(arr, indexLeft, index - 1); quickSort(arr, index + 1, indexRight);&#125; ① 第2行为递归的终止条件② 可能有人对第6、7行有疑问，为什么递归的时候少了index，因为index就是数组的基准值 1234567891011121314151617function position (arr, indexLeft, indexRight)&#123; let key = arr[indexLeft]; let low = indexLeft; let high = indexRight; while (low &lt; high)&#123; while (arr[high] &gt; key)&#123; high--; &#125; arr[low] = arr[high]; while (arr[low] &lt; key)&#123; low++; &#125; arr[high] = arr[low]; &#125; arr[low] = key; return low;&#125; ① 第5行判断数组长度大于1② 第6~9行从数组末端开始和基准值key比较，如果大于key则往前移，否则和第low个值交换③ 第10~13从数组头部开始和基准值key比较，如果小于key则往后移，否则和第high个值交换直到low不小于high，while循环结束，此时将基准值赋予角标为low处。 可以看下面的例子，增加以下理解 5 5 4 8 3 2 6 7 9 首先用5当作基准，使用i j两个指针分别从两边进行扫描，首先比较9和5，9比5大，j左移。继续比较，7&gt;5, 6&gt;5, j左移两次，接着比较2和5，2&lt;5,交换 5 2 4 8 3 _ 6 7 9 将2移至i原来所在的位置，同时把2原来所在的位置空出来(相当于空出来，其实2还留在原地)，并开始从左侧比较。4和5比较 5 2 4 8 3 _ 6 7 9 4&lt;5，不交换，i继续右移 5 2 4 _ 3 8 6 7 9 8&gt;5，将8与j所在的位置交换，j左移，将3与5比较 5 2 4 3 _ 8 6 7 9 3&lt;5，3移至i所在的位置，i继续右移，此时i=j，循环结束。 5 2 4 3 5 8 6 7 9 循环结束将基准值5移至空位。此时一轮排序到此结束，之后将以同样的方式继续比较，直到数据排列完成]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F01%2F06%2FAlgorithm%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 该算法是一种分治算法，其思想是将原始数据分割为较小的数据，直到每个数组只有一个元素，然后再将小数组归并为一个数组。 性能 时间复杂度总是为O(NlogN)，空间复杂度为O(N)，算法与初始序列无关，排序是稳定的。 代码实现 123456789101112131415161718192021222324252627282930313233343536function mergeSort(arr)&#123; let length = arr.length; if (length === 1)&#123; //递归终止条件 return; &#125; let middle = Math.floor(length/2); let arrayLeft = arr.slice(0, middle); let arrayRight = arr.slice(middle+1, length-1); merge(mergeSort(arrayLeft), mergeSort(arrayRight));&#125;function merge(arrayLeft, arrayRight)&#123; //数组合并和排序 let result = []; let indexLeft = 0; let indexRight = 0; while(indexLeft &lt; arrayLeft.length &amp;&amp; indexRight &lt; arrayRight.length)&#123; //谁小就将它放到数组里面 if (arrayLeft[indexLeft] &lt; arrayRight[indexRight])&#123; result.push(arrayLeft[indexLeft]); indexLeft++; &#125; else &#123; result.push(arrayRight[indexRight]); indexRight++; &#125; &#125; while(indexLeft &lt; arrayLeft.length)&#123; //将剩余的放到数组 result.push(arrayLeft[indexLeft]); indexLeft++; &#125; while(indexRight &lt; arrayRight.length)&#123; //将剩余的放到数组 result.push(arrayRight[indexRight]); indexRight++; &#125; return result; &#125; ① 注意递归终止条件(所有递归都必须注意的点)② 大数组通过mergeSort()分割为单位为1的小数组，直到递归终止③ 通过merge()将一个个单位为1的数组合并为大数组，合并的过程就是排序的过程]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2018%2F01%2F05%2FAlgorithm%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 依次选择一个待排序的数据，插入到前边已排好序的序列中。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，比较次数与初始序列有关。 代码实现 123456789101112function insertSort(arr)&#123; let length = arr.length; for (let i = 1; i &lt; length - 1; i++)&#123; for (let j = i; j &gt; 0; j--)&#123; if (arr[j] &lt; arr[i])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; else &#123; break; &#125; &#125; &#125;&#125; 外层循环从数组的第二项开始遍历，内层循环从后往前遍历，如果小于外层数值，则插入(交换)当前位置 优化 123456789101112131415161718function insertSort(arr)&#123; let length = arr.length; let temp = 0; let index = 0; for (let i = 1; i &lt; length; i++)&#123; temp = arr[i]; index = i; for (let j = i; j &gt; 0; j--)&#123; if (temp &lt; arr[j-1])&#123; arr[j] = arr[j-1]; index = j - 1; &#125; else &#123; break; &#125; &#125; arr[index] = temp; &#125;&#125; 外层循环从数组的第二项开始遍历，内层循环从后往前遍历，如果小于外层数值，则将当前值往后移(10行)，并将当前值的角标记录下来(11行)，最后我们将temp赋给空出来的那个位置。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F01%2F04%2FAlgorithm%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 找到数据结构中的最小值，并记录其角标，将其放到第一位，接着找到第二小的值并把它放到第二位，以此类推。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是不稳定的，每次都能确定一个元素所在的最终位置，比较次数与初始序列无关。 代码实现 1234567891011121314function selectionSort(arr)&#123; let length = arr.length; for (let i = 0; i &lt; length - 1; i++)&#123; let min = i; for (let j = i; j &lt; length; j++)&#123; if (arr[min] &gt; arr[j])&#123; min = j; &#125; &#125; if (i !== min)&#123; [arr[i], arr[min]] = [arr[min], arr[i]]; &#125; &#125;&#125; 额外维护一个变量min来记录最小数据元素对应的角标。内层循环通过比对来寻找最小元素的角标，外层循环负责在min变动的时候对数据元素进行交换。 选择排序与冒泡排序 冒泡排序每次发现有更小元素就立即交换到序列首位，而选择排序发现有更小元素时，只是记录其下标，等到内层循环完之后，在将最小元素交换到首位]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F01%2F03%2FAlgorithm%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想 相邻的数据进行两两比较，较大的数放到后面，这样每次都能找到一个最大的数，循环执行n次就能把全部数据按顺序排列。冒泡有两种形式，一种是把小的冒泡到前边去，另一种是把大的元素冒泡到后边。 性能 时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。 代码实现 ①将大的数据元素放到后面 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = 0; j&lt; arr.length - 1; j++)&#123; if (arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] //es6语法 &#125; &#125; &#125;&#125; ②将小的数据元素放到前面 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = i + 1; j&lt; arr.length; j++)&#123; if (arr[i] &gt; arr[j])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] //es6语法 &#125; &#125; &#125;&#125; 内层循环过程中，两两比较，将较大/小的数据元素交换到下一位置，外层循环每完成一次，当前序列的最大/小的元素就会冒到当前序列的尾位置 优化 12345678910function bubbleSort (arr)&#123; let length = arr.length; for (let i = 0; i&lt; arr.length; i++)&#123; for (let j = 0; j&lt; arr.length - 1 - i; j++)&#123; // this line if (arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] //es6语法 &#125; &#125; &#125;&#125; 外层循环每执行一次，最前或最后的元素都是最大或最小的，所以我们内层循环时可去掉已排好序的数据。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs scope(作用域)]]></title>
    <url>%2F2017%2F12%2F07%2FAngularJs%2FAngularJs%20%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[$rootScope每个AngularJs应用默认有一个根作用域–$rootScope， 根作用域位于最顶层，作为其他作用域的父作用域，可作用于整个应用中。$scope scope(作用域)对应MVC模式的Model，是应用在HTML(视图)和JavaScript(控制器)之间的纽带，可应用在视图和控制器上。 scope是表达式执行的上下文，同时scope也是一个对象，有可用的方法和属性。 一、变量的取值和赋值1234567891011121314&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;button ng-click="number = number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; function parentCtrl($scope)&#123; $scope.number = 1;&#125;function childCtrl($scope)&#123; &#125; 效果： 界面上显示了两个1，但当我们点击按钮之后，childCtrl作用域内的数据改变了，parentCtrl作用域内的数据没有改变 分析： ①childCtrl作用域继承了parentCtrl作用域(类似于JavaScript的原型链继承)，所以childCtrl作用域可以访问到parentCtrl的内容。 ②点击按钮后childCtrl作用域就会创建一个number基础类型变量，当childCtrl已有某个基础类型变量就不会访问原型链。 解决： ①可以使用$parent来指定上级作用域改变 1234567&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;button ng-click="$parent.number = number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ②使用引用类型变量，内外层作用域均是data对象的引用，修改对象的属性，引用的还是同一个变量。 1234567891011121314&lt;div ng-controller="parentCtrl"&gt; &lt;span&gt;&#123;&#123;data.number&#125;&#125;&lt;/span&gt; &lt;div ng-controller="childCtrl"&gt; &lt;span&gt;&#123;&#123;data.number&#125;&#125;&lt;/span&gt; &lt;button ng-click="data.number = data.number +1"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; function parentCtrl($scope)&#123; $scope.data.number = 123';&#125;function childCtrl($scope)&#123; &#125; ng-if、ng-repeat、ng-switch、ng-include等指令也会产生新作用域 二、Directive中的作用域1234567891011121314151617.directive("myDirective", function () return &#123; restrict: "AE", scope: &#123; name: '@myName', age: '=', changeAge: '&amp;changeMyAge' &#125;, replace: true, template: "&lt;div class='my-directive'&gt;" + "名字：&lt;span ng-bind='name'&gt;&lt;/span&gt;&lt;br/&gt;" + "年龄：&lt;span ng-bind='age'&gt;&lt;/span&gt;&lt;br/&gt;" + "修改名字：&lt;input type='text' ng-model='name'&gt;&lt;br/&gt;" + "&lt;button ng-click='changeAge()'&gt;修改年龄&lt;/button&gt;" + " &lt;/div&gt;" &#125;&#125; ①scope：false 当scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。 ②scope：true 当scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承的父作用域；可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。 ③scope：{}@ 这是一个单项绑定的前缀标识符 &lt;div my-directive my-name=&quot;&quot;&gt;&lt;/div&gt; 属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过&#123;&#123; &#125;&#125;使用来绑定数据。 = 这是一个双向数据绑定前缀标识符 &lt;div my-directive age=&quot;age&quot;&gt;&lt;/div&gt; 数据的双向绑定要通过=前缀标识符实现，所以不可以使用。 &amp; 这是一个绑定函数方法的前缀标识符 &lt;div my-directive change-my-age=&quot;changeAge()&quot;&gt;&lt;/div&gt; 属性的名字要用-将多个个单词连接。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 问题总结]]></title>
    <url>%2F2017%2F12%2F01%2FAngularJs%2FAngularJs%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AngularJs 问题总结 一、ng-if/ng-show 最根本的区别是页面是否会生成此DOM元素 二、ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？ 会提示 Duplicates in a repeater are not allowed.，数据与DOM之间一对一的关系在数据相同的情况下不成立。通过 track by key key 为数组的唯一标识，目的是建立数组与DOM的关联。 三、ionic ion-slide-box bugion-slide-box在数量为两个的情况下会造成 ion-slide的数量由2个变成4个①修改slideChanged方法 12345678$scope.slideChanged = function(index) &#123; $scope.slideIndex = index; if ( ($ionicSlideBoxDelegate.count() -1 ) == index ) &#123; $timeout(function()&#123; $ionicSlideBoxDelegate.slide(0); &#125;,3000); &#125; &#125;; 在数据为2的时候手动调用 $ionicSlideBoxDelegate.slide(0) 跳转到第一个 ②修改源码 123456789$scope.numSlides = function() &#123; if (!slideBox._length)&#123; slideBox._length = slideBox.slidesCount() || 0; &#125; return new Array(slideBox._length);&#125;;$scope.$watch('currentSlide', function(v) &#123; selectPage(v%(slideBox.slidesCount()||0));&#125;); 在 ionic.bundle.js 的第63314行附近，修改以上两个方法。执行slideBox个数的取余操作 四、在Html页面调取JS原生方法(parseInt)失效？ 在页面中，都不能直接调用原生的JS 方法，因为这些并不存在于与页面对应的Controller 的$scope 中 更新中。。。。。。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git The Requested URL return error 403]]></title>
    <url>%2F2017%2F11%2F29%2Ffront%2FThe%20Requested%20URL%20return%20error%20403%2F</url>
    <content type="text"><![CDATA[一、 问题描述git在 pull/push 代码的时候提示：The Requested URL return error 403，这表示我们没有权限来pull/push相关代码 二、 问题分析 有可能你是真的没有权限(认真脸) 你修改了git仓库的用户名和密码，导致你内存和硬盘中缓存的账号密码不能使用 三、问题处理1、执行git config --list，查看git的配置信息 图中红色部分内容[user] 为你的git账号配置信息，[credential]为你的这些信息存储位置 2、执行vim .git-credentials，查看credential中缓存的账户 2、 执行git help -a | grep credential，查看git的信息存储位置 git help -a | grep credential命令查看自己系统支持的crendential, cache 代表内存中的缓存，store 代表磁盘。git config credential.helper命令可以看到 cache、store、osxkeychain(钥匙串)中是否还有git的配置信息。由图中我们可以得出git config还存储在store中 3、一般配置方法： git config --global (--replace-all) user.name &quot;你的用户名&quot; git config --global (--replace-all) user.email &quot;你的邮箱&quot; 4、如果上述步骤没有效果，我们就需要清除缓存(.gitconfig) git config --local --unset credential.helper git config --global --unset credential.helper git config --system --unset credential.helper 具体介绍可以查看这里, 可能有多处.gitconfig文件 四、 重复输入用户名密码清除缓存之后我们每次提交代码的时候都需要输入用户名和密码 git config --global credential.helper store 或者 执行修改.gitconfig配置文件，把以下内容放置到最后 [credential] helper = store 执行 vim .gitconfig查看 本次问题到此结束，如有问题请留言 友情链接关于credential的介绍可以点击这里关于.gitconfig清除缓存可以点击这里]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova 保存图片到本地]]></title>
    <url>%2F2017%2F11%2F15%2FAngularJs%2FCordova%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[我们将介绍两种方式将照片保存到本地 官方下载插件FileTransfer 这种方式会有一个弊端就是图片在相册里面找不到需要刷新一下系统目录或者重启一下手机才能在相册里面查看到图片但是可以下载动图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051vm.url = encodeURI(baseConfig.imgPath + vm.nowImgs[vm.nowImgIndex]);vm.fileName = vm.nowImgs[vm.nowImgIndex].split("/").pop();var fileTransfer = new FileTransfer();var trustHosts = true;var options = &#123; headers: &#123; "Authorization": 'access_token' &#125; &#125;;//Android：vm.fileURL = cordova.file.externalRootDirectory;window.resolveLocalFileSystemURL(vm.fileURL, function (fileEntry) &#123; fileEntry.getDirectory("Giti", &#123;create: true, exclusive: false&#125;, function (fileEntry) &#123; fileEntry.getDirectory("img", &#123;create: true, exclusive: false&#125;, function (fileEntry) &#123; fileTransfer.download( vm.url, fileEntry.toURL() + vm.fileName, function (success) &#123; &#125;, function (error) &#123; &#125;, options, trustHosts ); &#125;, function () &#123; publicMethod.showLoadingNoBackdrop('img文件夹创建失败'); &#125;); &#125;, function () &#123; publicMethod.showLoadingNoBackdrop('Giti文件夹创建失败'); &#125;);&#125;);// iOSvm.fileURL = cordova.file.documentsDirectory + vm.fileName;window.requestFileSystem(LocalFileSystem.PERSISTENT, 5 * 1024 * 1024, function (fs) &#123; fs.root.getDirectory('Giti', &#123;create: true, exclusive: false&#125;, function (directory) &#123; fileTransfer.download( vm.url, directory.nativeURL + vm.fileName, function (success) &#123; &#125;, function (error) &#123; &#125;, trustHosts, options ); &#125;);&#125;); Canvas2ImagePlugin插件 这种方法可以直接在相册里面看到图片但是动图看不到，下面是参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445function keepImg()&#123; var success = function (msg) &#123; &#125;; var error = function (err) &#123; &#125;; saveImageToPhone(vm.url, success, error);&#125; function saveImageToPhone(url, success, error) &#123; var canvas, context, imageDataUrl, imageData; var img = new Image(); img.src = url; img.onload = function () &#123; console.log('Img size: ' + img.naturalWidth + 'x' + img.naturalHeight); canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; context = canvas.getContext('2d'); context.drawImage(img, 0, 0); try &#123; imageDataUrl = canvas.toDataURL('image/jpeg', 1.0); imageData = imageDataUrl.replace(/data:image\/jpeg;base64,/, ''); cordova.exec( success, error, 'Canvas2ImagePlugin', 'saveImageDataToLibrary', [imageData] ); &#125; catch (e) &#123; error(e.message); &#125; &#125;; try &#123; img.src = url; console.log("153" + img.src); &#125; catch (e) &#123; console.log("156" + img.src); error(e.message); &#125;&#125;]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Redux(二)-Redux使用]]></title>
    <url>%2F2017%2F09%2F05%2FReact%20Native%2FReact%20Native%20Redux(%E4%BA%8C)%20-%20Redux%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言：redux重构(一)的时候大概讲了redux的各个部分的定义，这一部分主要讲解一下redux的具体使用。项目地址后端LeanCloud redux 使用1.项目目录结构 redux能用到的结构都在图上提现出来了，下面将以Login为例介绍每部分的具体内容 2.ActionTypes - 统一定义了action供别处调用123export const ERROR_ACTION = 'ERROR_ACTION';export const LOGIN_PERFORM_ACTION = 'LOGIN_PERFORM_ACTION';export const LOGIN_ACTION = 'LOGIN_ACTION'; 3.LoginAction - 事件的发起者12345678910111213141516171819202122232425262728293031323334353637import NetUtil from '../utils/NetUtil';import * as types from '../constants/ActionTypes';import Global from '../constants/Global'; export function performLoginAction(username, password) &#123; return (dispatch) =&gt; &#123; dispatch(performLogin()); let url = Global.LOGIN + "username=" + username + "&amp;password=" + password; NetUtil.get(url, function (res) &#123; if (res.hasOwnProperty('code')) &#123; dispatch(errorAction(res)); &#125; else &#123; dispatch(successLogin(res)) &#125; &#125;) &#125;&#125; function performLogin() &#123; return &#123; type: types.LOGIN_PERFORM_ACTION &#125;&#125; function successLogin(result) &#123; return &#123; type: types.LOGIN_ACTION, data: result &#125;&#125; function errorAction(result) &#123; return &#123; type: types.ERROR_ACTION, data: result &#125;&#125; 首先import我们前面定义的ActionType、Global(全局常量)、NetUtil(封装的网络请求) 然后我们dispatch(分发)各个动作，此处我们dispatch了performLogin这一动作，然后进行网络请求，根据请求成功与否我们dispatch了successLogin和errorAction这两个动作。 这里的主要区别就是动作的不同，这里仅仅是触发了不同的动作，之后我们会根据不同的动作来处理不同的数据。 在这里我们根据不同的action来选择是否传递数据以供reducer使用 4.LoginReducer - 根据Action的不同来改变state(数据)12345678910111213141516171819202122232425262728293031import * as types from '../constants/ActionTypes'; const initialState = &#123; loading : false, data:&#123;&#125;, status: null&#125;; export default function login(state = initialState, action)&#123; switch (action.type) &#123; case types.LOGIN_PERFORM_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: true, status: 'doing' &#125;); case types.LOGIN_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: false, status: 'success', data: action.data &#125;); case types.ERROR_ACTION: return Object.assign(&#123;&#125;, state, &#123; loading: false, status: 'failed', data: action.data &#125;); default: return state; &#125;&#125; 引入ActionType 定义默认state的数据结构 根据不同的action修改state，这里使用了ES6中的Object.assign() 这里的action.data是LoginAction传递过来的 5. 页面 -action的触发和state的改变1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123;Component&#125; from 'react';import &#123; StyleSheet, View&#125; from 'react-native';import Util from '../utils/Util';import Tabs from '../containers/Tabs';import LoadingView from '../components/LoadingView'; import &#123;connect&#125; from 'react-redux';import TextButton from '../components/TextButton';import &#123;performLoginAction&#125; from '../actions/LoginAction';import Register from '../containers/Register';class Login extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; username: '', password: '' &#125;; &#125; render() &#123; const &#123;loginReducer&#125; = this.props; console.log(loginReducer); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;/View&gt; ) &#125; componentDidUpdate() &#123; const &#123;loginReducer&#125; = this.props; if (loginReducer.status === 'success') &#123; const &#123;navigator&#125; = this.props; navigator.push(&#123; name: 'Tabs', component: Tabs &#125;) &#125; if (loginReducer.status === 'failed')&#123; Util.showToastCenter(loginReducer.data.error); &#125; &#125; _login = () =&gt; &#123; const &#123;navigator, dispatch&#125; = this.props; let username = this.state.username; let password = this.state.password; if (Util.isEmpty(username)) &#123; Util.showToastCenter('用户名为空'); return; &#125; if (Util.isEmpty(password)) &#123; Util.showToastCenter('密码为空'); return; &#125; dispatch(performLoginAction(username, password)); &#125;;&#125; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#f5f5f5' &#125;&#125;); function mapStateToProps(state) &#123; const &#123;loginReducer&#125; = state; return &#123; loginReducer &#125;&#125; export default connect(mapStateToProps)(Login); 首先我们导入LoginAction里面的方法performLoginAction，在我们登录的时候调用 当触发登录动作的时候调用performLoginAction() 这样我们的整个流程就走通了，但是还差最后一步，当LoginReducer改变了state时，页面是怎么接受数据的呢？这就是下面要介绍的connect 6. connect: 连接 react 组件和 store12345678function mapStateToProps(state) &#123; const &#123;loginReducer&#125; = state; return &#123; loginReducer &#125;&#125;export default connect(mapStateToProps)(Login); mapStateToProps: 组件将会监听store的数据变化，只要store发生变化，就会回调该方法。然后我们就可以在componentWillReceiveProps()方法中接收state的改变。 到目前为止还差store中的state管理、reducer的管理 7.rootReducers1234567891011import &#123;combineReducers&#125; from 'redux';import loginReducer from './LoginReducer';import registerReducer from './RegisterReducer';import homeReducer from './HomeReducer'; const rootReducers = combineReducers(&#123; loginReducer, registerReducer, homeReducer&#125;);export default rootReducers; 将不同的reducer导入，并使用combineReducers 将他们统一管理 8.store12345678import &#123;createStore, applyMiddleware&#125; from 'redux';import thunkMiddleware from 'redux-thunk';import rootReducers from '../reducers/rootReducers';const createStoreWithMiddleware = applyMiddleware(thunkMiddleware)(createStore);export default function configureStore(initialState) &#123; const store = createStoreWithMiddleware(rootReducers, initialState); return store;&#125; 所有的state都存储在这里 9. Provider12345678910111213141516171819import React, &#123;Component&#125; from 'react';import App from '../lifeStyle/App'; import configureStore from '../lifeStyle/store/configureStore';import &#123;Provider&#125; from 'react-redux'; const store = configureStore(); class root extends Component&#123; render()&#123; return( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; ) &#125;&#125; export default root; Provider 这个模块是作为整个 App 的容器，在你原有的 App Container 的基础上再包上一层，它的工作很简单，就是接受 Redux的 store 作为 props 梳理流程：首先是用户行为或者程序触发来生成不同的Action，此时根据不同的Action来生成不同的数据，store通过dispatch来触发action, 之后在Reducer中根据action type的不同将生成不同的state, store 中的state集合发生改变，并最终作用到界面上。整个过程可以理解为：UI – &gt; Action – &gt; Reducer – &gt; Store – &gt; UI, 完美的体现了单向数据流。这有点类似于Android中的MVP模式，将业务逻辑和页面的变化分割开来，各司其职互不干扰。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 双向绑定原理(数据绑定机制)]]></title>
    <url>%2F2017%2F08%2F26%2FAngularJs%2FAngularJs%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86(%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6)%2F</url>
    <content type="text"><![CDATA[AngularJs 为 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view(html) 上时 AngularJs 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发。$digest 会遍历所有的 $watch。从而更新DOM。 $watch这有点类似于我们的观察者模式，在当前作用域$scope下，我们创建一个监控器$watchers和一个监听器$watch，$watchers 负责管理所有的 $watch，当我们每次绑定到UI上的时候就自动创建一个$watch，并把它放到 $watchers。 controller.js 1234app.controller('MainCtrl', function($scope) &#123; $scope.Hello = "Hello"; $scope.world = "World";&#125;); index.html 1&lt;div&gt;&#123;&#123;Hello&#125;&#125;&lt;/div&gt; 这里，即便我们在$scope上添加了两个变量，但是只有一个绑定在了UI上，因此在这里只生成了一个$watch $digest当浏览器接收到可以被angular context处理的事件时，$digest循环就会触发。$digest将会遍历我们的$watch，如果$watch没有变化，这个循环检测就将停止，如果有至少一个更新过，这个循环就会再次触发，直到所有的$watch都没有变化。这样就能够保证每个model都已经不会再变化。这就是脏检查(Dirty Checking)机制controller.js 1234567app.controller('MainCtrl', function() &#123; $scope.name = "Foo"; $scope.changeFoo = function() &#123; $scope.name = "Bar"; &#125;&#125;); index.js 12&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;button ng-click="changeFoo()"&gt;Change the name&lt;/button&gt; 当我们按下按钮 浏览器接收到一个事件，进入angular context。 $digest循环开始执行，查询每个$watch是否变化。 由于监视$scope.name的$watch报告了变化，它会强制再执行一次$digest循环。 新的$digest循环没有检测到变化。 更新与$scope.name新值相应部分的DOM。 $apply$apply 我们可以直接理解为刷新UI。如果当事件触发时，你调用$apply，它会进入angular context，如果没有调用就不会进入，之后的$digest检测机制就不会触发123456789101112131415app.directive('clickable', function() &#123; return &#123; restrict: "E", scope: &#123; foo: '=' &#125;, template: '&lt;ul style="background-color: lightblue"&gt;&lt;li&gt;&#123;&#123;foo&#125;&#125;&lt;/li&gt;&lt;/ul&gt;', link: function(scope, element, attrs) &#123; element.bind('click', function() &#123; scope.foo++; console.log(scope.foo); &#125;); &#125; &#125;&#125;); 当我们调用clickable指令的时候，我们可以看到foo的值增加了，但是界面上显示的内容并没有改变。$digest脏检测机制没有触发，检测foo的$watch就没有执行。 $apply()方法的两种形式1) 无参1$scope.$apply(); 使用12345element.bind('click', function() &#123; scope.foo++; //if error scope.$apply();&#125;); 当我们使用这种形式的时候，如果在scope.$apply之前程序发生异常，那scope.$apply没有执行，界面就不会更新 2) 有参123$scope.$apply(function()&#123; ...&#125;) 使用12345element.bind('click', function() &#123; scope.$apply(function() &#123; scope.foo++; &#125;);&#125;) 如果用这种形式，即使后面的发生异常，数据还是会更新。 在 AngularJS 中使用 $watch常用的使用方式： 12345$scope.name = 'Hello';$scope.$watch('name', function(newValue, oldValue) &#123; if (newValue === oldValue) &#123; return; &#125; $scope.updated++;&#125;); 传入到$watch()中的第二个参数是一个回调函数，该函数在name的值发生变化的时候会被调用。 如果要监听的是一个对象，那还需要第三个参数： 12345$scope.data.name = 'Hello';$scope.$watch('data', function(newValue, oldValue) &#123; if (newValue === oldValue) &#123; return; &#125; $scope.updated++;&#125;, true); 表示比较的是对象的值而不是引用，如果不加第三个参数true，在 data.name 变化时，不会触发相应操作，因为引用的是同一引用。 总结1) 只有在$scope变量绑定到页面上，才会创建 $watch2) $apply决定事件是否可以进入angular context3) $digest 循环检查model时最少两次，最多10次(多于10次抛出异常，防止无限检查)4) AngularJs自带的指令已经实现了$apply，所以不需要我们额外的编写5) 在自定义指令时，建议使用带function参数的$apply]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 流式布局]]></title>
    <url>%2F2017%2F08%2F22%2FAngularJs%2FAngularJs%20%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[移动端实现图片高度不固定的照片墙效果 流式布局照片墙一、 HTML123&lt;div class='box' ng-repeat="img in imgs track by $index" on-finish-render-filters&gt; &lt;img class='item' ng-src='&#123;&#123;img&#125;&#125;'&gt;&lt;/div&gt; 二、JS 获取所有布局元素12345678910function getAllChild(parent, className) &#123; vm.childName = parent.getElementsByTagName("*"); vm.tempArray = []; for (var i in vm.childName) &#123; if (vm.childName[i].className === className) &#123; vm.tempArray.push(vm.childName[i]); &#125; &#125; return vm.tempArray; &#125; 获取类选择器中class=&#39;box&#39;中的所有class=‘item’的元素，并放到数组； 获取每列中高度的最小值所对应的列号 1234567function getMinIndex(onlyOneColsArr, minHeight) &#123; for (var i in onlyOneColsArr) &#123; if (onlyOneColsArr[i] === minHeight) &#123; return i; &#125; &#125;&#125; 重新排列子元素的位置 123456789101112131415161718192021222324/* * 排列子元素的位置，并获取每列的高度 * @param &#123;Array&#125; childArr 子元素 * @param &#123;Number&#125; num 列数 * */function getMinHeightOfCols(childArr, num) &#123; for (var i = 0; i &lt; childArr.length; i++) &#123; if (i &lt; num) &#123; //获取每列的高度 vm.colsHeightArray[i] = childArr[i].offsetHeight; &#125; else &#123; // 获取每列中高度的最小值 var minHeightOfCols = Math.min.apply(null, vm.colsHeightArray); // 获取列高度最小值所对应的index var minHeightOfIndex = getMinIndex(vm.colsHeightArray, minHeightOfCols); // 设置子元素的位置 childArr[i].style.position = "absolute"; childArr[i].style.top = minHeightOfCols + 'px'; childArr[i].style.left = childArr[minHeightOfIndex].offsetLeft + "px"; //重置高度最小的列的高度 vm.colsHeightArray[minHeightOfIndex] += childArr[i].offsetHeight; &#125; &#125;&#125; 方法主体 123456789function photoWall(parent, child) &#123; /* * 获取class为parent的元素 * */ vm.parent = document.getElementsByClassName(parent); //获取class为child的div var childArray = vm.getAllChild(vm.parent, child); vm.getMinHeightOfCols(childArray, 2);&#125; 方法调用 1vm.photoWall('box', 'item'); 以上就是我们页面重新布局的所有代码，细心的小伙伴可能已经发现html上面多了on-finish-render-filters，这个是干什么用的呢，请看下文 三、自定义指令 定义指令 12345678910111213angular.module('onFinishRenderFilterModule', []) .directive('onFinishRenderFilters', function ($timeout) &#123; return &#123; restrict: 'A', link: function (scope, element, attr) &#123; if (scope.$last === true) &#123; $timeout(function () &#123; scope.$emit('ngRepeatFinished'); &#125;, 200); &#125; &#125; &#125;; &#125;); 调用 12345$scope.$on('ngRepeatFinished', function (ngRepeatFinishedEvent) &#123; $timeout(function () &#123; vm.photoWall('box', 'item'); &#125;, 200);&#125;); 指令类型：属性(restrict:&#39;A&#39;), 在界面渲染时调用on-finish-render-filters 属性，然后再通过 $emit 向 controller 发送广播，最后再使用 $on 来接收广播，绘制流式布局。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs之factory、service、provider]]></title>
    <url>%2F2017%2F08%2F16%2FAngularJs%2FAngularJs%E4%B8%ADfactory%E3%80%81service%E3%80%81provider%2F</url>
    <content type="text"><![CDATA[factory、service、provider 我们先通过一段代码来认识一下factory、service、provider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var myApp = angular.module('myApp', []);/* * Factory */myApp.factory('Factory', function() &#123; return &#123; sayHello: function() &#123; return "Hello, 张先生"; &#125; &#125;;&#125;);/* * Service */myApp.service('Service', function() &#123; this.sayHello = function() &#123; return "Hello, 张先生"; &#125;;&#125;);/* * Provider */ myApp.provider('Provider', function() &#123; this.name = '先生'; this.$get = function() &#123; var name = this.name; return &#123; sayHello: function() &#123; return "Hello, " + name; &#125; &#125; &#125;; this.setName = function(name) &#123; this.name = name; &#125;;&#125;);/* * config provider */ myApp.config(function(myProvider)&#123; myProvider.setName('张先生');&#125;);/* * 方法调用 */function MyCtrl($scope, Provider, Factory, Service) &#123; $scope.hellos = [ Provider.sayHello(), Factory.sayHello(), Service.sayHello()];&#125; factory: factory是以个可注入的function。当使用factory来创建服务的时候，相当于新创建了一个对象，然后在这个对象上新添属性，最后返回这个对象。service: service是一个可注入的构造函数。service是单例模式的。当使用service创建服务的时候，相当于使用new关键词进行了实例化。因此，你只需要在this上添加属性和方法，服务就会自动的返回this。provider是一个可配置的factory。provider是唯一一种可以创建用来注入到config()函数的服务的方式。$get 中返回的，就是用 factory 创建 service 的内容. 想在你的服务启动之前，进行一些模块化的配置的话，就使用provider。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs 输入框自动变化高度]]></title>
    <url>%2F2017%2F08%2F14%2FAngularJs%2FAngularJs%20%E8%BE%93%E5%85%A5%E6%A1%86%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[AngularJs 输入框自动变化高度 当你想实现一个高度自增长的文本框的时候，也许你首先想到的是textarea，但是使用它太麻烦而且还会有很多问题，下面我们来介绍一种简单有效的方式。 div div中有个属性contenteditable，当把它设为true的时候，这个div就会变为可编辑状态，所以我们可以利用这个属性来使div变为文本域，下面看代码 html 1&lt;div contenteditable="true" id="article-comment-content" class="article-comment-content" onblur="contentBlur()" ng-model="vm.articleComment.content"&gt;&lt;/div&gt; css 1234567891011121314.article-comment-content&#123; padding: 10px; line-height: 20px; font-size: 14px; background: white; -webkit-user-select: text;&#125;.article-comment-content:empty:before &#123; content: '请输入回帖内容'; color: #999;&#125;.article-comment-content:focus:before &#123; content: none;&#125; 以上我们实现了文本输入框并自动增加文本框的高度，并设置了文本框的placeholder。但是细心的你可能要问了，应该怎么实现数据绑定呢？下面我们接着来看这个问题： 其实我们可以通过 var content = $(‘#article-comment-content’).eq(0)[0].textContent 来获取输入框的值，但是这样是不能进行双向数据绑定的。对于这个问题我们可以使用自定义指令的方式123456789101112131415.directive('contenteditable', function () &#123; return &#123; require: 'ngModel', link: function (scope, element, attrs, ctrl) &#123; element.bind('input', function () &#123; scope.$apply(function () &#123; ctrl.$setViewValue(element.html()); &#125;); &#125;); ctrl.$render = function () &#123; element.html(ctrl.$viewValue); &#125;; &#125; &#125;;&#125;); 或者 1234567891011121314151617181920212223app.directive('contenteditable', function() &#123; return &#123; restrict: 'A', // 只用于属性 require: '?ngModel', link: function(scope, element, attrs, ngModel) &#123; if (!ngModel) &#123; return; &#125; ngModel.$render = function() &#123; element.html(ngModel.$viewValue || ''); &#125;; element.on('blur keyup change input', function() &#123; scope.$apply(readViewText); &#125;); function readViewText() &#123; var html = element.html(); if (attrs.stripBr &amp;&amp; html === '&lt;br&gt;') &#123; html = ''; &#125; ngModel.$setViewValue(html); &#125; &#125;&#125;; 这样我们就可以实现数据的双向绑定了。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Redux(一)-Redux介绍]]></title>
    <url>%2F2017%2F08%2F10%2FReact%20Native%2FReact%20Native%20Redux(%E4%B8%80)%20-%20Redux%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言：本文将着重梳理清 redux 使用中的各个关键词的概念，以加深对redux的理解项目地址 redux是什么 redux 是 JavaScript 状态容器，提供对 JavaScript 应用状态的管理 redux安装 安装 react-redux 1npm install --save react-redux 安装 redux 1npm install --save redux 安装 redux-thunk 1npm install --save redux-thunk redux介绍redux由三部分组成：Action、Reducer、Store Action：事件的发起者(动作)，由用户或程序触发 Reducer：根据Action 类型来做出不同的响应，返回新的 state Store：存储 state 的集合 当由用户或者程序触发某一个具体的动作时，Reducer 将对 Action 进行识别, 并返回新的state，最终存储在 store 中的 state 发生改变，从而导致界面的变化。 好处 单一数据源：数据只存在于 store 中，无论是开发还是调试都方便很多 state 是只读的：只有通过触发 action 才能修改 state Provider Provider 这个模块是作为整个 App 的容器，在你原有的 App Container 的基础上再包上一层，它的工作很简单，就是接受 Redux 的 store 作为 props dispatch dispatch 有分发之意。我们知道由用户或者程序触发的 Action 由 Reducer 做出响应从而引起 state 的改变。而 dispatch 就扮演了他们两者中的传播媒介。简单来说：首先 store 中维护了一个 state，我们 dispatch 一个 action 会触发 reducer 检测，接下来 reducer 根据这个 action 更新 state connect connect方法的作用是连接 react 组件和 store，也就是说通过 connect 方法子组件可以获取 store 中的 state 和 dispatch。redux 的 connect 的含义是可以连接任意函数，这些函数的参数可以注入 store、state、dispatch。connect 可以将组件和 reducer 相关联。 combineReducers 我们知道 reducer 是一个纯函数，接收已有的的 state 和 action，返回新的 state。当state比较多或复杂时，我们想让每个 reducer 只管理一部分 state 数据。而combineReducers 可以将所有的部分state友好的合并成一个全局的 state。其实combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理,然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象 applyMiddleware applyMiddleware是中间件，使用于 action 被发起之后，到达 reducer 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由 异步Action 当有网络请求的时候我们需要用到异步操作，这时候我们就需要使用到Thunk ``middleware 或者 redux-promise 中间件来 强烈建议Redux 中文文档Redux 英文文档]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native AsyncStorage 封装]]></title>
    <url>%2F2017%2F07%2F22%2FReact%20Native%2FReact%20Native%20AsyncStorage%20%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在Android开发中有一个以key-value形式轻量级的数据存储方式—SharedPreferences, 类似的React Native中也有一个–AsyncStorage AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的 API1static getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) 读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 1static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) 将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 1static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) 删除一个字段。返回一个Promise对象。 封装1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';import &#123;Component&#125; from 'react';import &#123; AsyncStorage&#125; from 'react-native';import JsonUtil from '../utils/JsonUtil' class StorageUtil extends Component &#123; /* * 保存 * */ static save(key, value, callback) &#123; return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value), callback); &#125; /* * 获取 * */ static get(key) &#123; return AsyncStorage.getItem(key).then((value) =&gt; &#123; const jsonValue = JsonUtil.strToJson(value); return jsonValue; &#125;) &#125; /* * 更新 * */ static update(key, value) &#123; StorageUtil.get(key).then((item) =&gt; &#123; value = typeof value === 'string' ? value : Object.assign(&#123;&#125;, item, value); return AsyncStorage.setItem(key, JsonUtil.jsonToStr(value)); &#125;) &#125; /* * 删除 * */ static delete(key, callback) &#123; AsyncStorage.removeItem(key, callback); &#125;&#125; export default StorageUtil; 其中JsonUtil是封装的一个Json格式转换的工具类，其中保存和删除添加了一个回调函数 调用保存123StorageUtil.save('sessionToken', res.sessionToken, function () &#123; console.log('成功');&#125;); 调用12345StorageUtil.get('sessionToken').then((username) =&gt; &#123; this.setState(&#123; username:username &#125;)&#125;);]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native TextInput 高度自适应]]></title>
    <url>%2F2017%2F06%2F30%2FReact%20Native%2FReact%20Native%20TextInput%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[有时我们需要根据默认的文字来显示TextInput的高度，而且可以随着文字的输入自动增加TextInput的高度。下面我们就来看一下这个是如何实现的： TextInput属性介绍 代码伺候(去除无关代码)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Created by Cral-Gates on 2017/5/11. */import React, &#123;Component&#125; from 'react';import &#123; StyleSheet, Text, View, TextInput, ScrollView&#125; from 'react-native';import NavigationBar from '../component/NavigationBar';import NetUtil from '../utils/NetUtil';import Global from '../utils/Global'; class NoteDetail extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; noteContent: '', height: 50, &#125; &#125; componentDidMount() &#123; this.setState(&#123; noteContent: this.props.noteDetail.content, &#125;); &#125; render() &#123; return ( &lt;View&gt; &lt;ScrollView&gt; &lt;TextInput style=&#123;[styles.noteDetailContent, &#123;height: this.state.height&#125;]&#125; multiline=&#123;true&#125; secureTextEntry=&#123;false&#125; underlineColorAndroid=&#123;'transparent'&#125; value=&#123;this.state.noteContent&#125; onChangeText=&#123;(noteContent) =&gt; this.setState(&#123;noteContent&#125;)&#125; onChange=&#123;() =&gt; this.onChange.bind(this)&#125; onContentSizeChange=&#123;(event) =&gt; this.onContentSizeChange(event)&#125;/&gt; &lt;/ScrollView&gt; &lt;/View&gt; ) &#125; onChange = (event) =&gt; &#123; this.setState(&#123; noteContent: event.nativeEvent.text, height: event.nativeEvent.contentSize.height &#125;); &#125;; onContentSizeChange = (event) =&gt; &#123; this.setState(&#123; height: event.nativeEvent.contentSize.height &#125;); &#125;&#125; const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: '#f5f5f5' &#125;, noteDetailTitle: &#123; backgroundColor: 'white', marginTop: 10, marginBottom: 2, marginLeft: 20, marginRight: 20, height: 35, fontSize: 18, fontWeight: '600' &#125;, noteDetailContent: &#123; backgroundColor: 'white', marginLeft: 20, marginRight: 10, lineHeight: 20, fontSize: 16 &#125;&#125;); export default NoteDetail; 首先创建构造函数 1234567constructor(props) &#123; super(props); this.state = &#123; noteContent: '', //笔记内容 height: 50, //默认高度 &#125; &#125; 然后设置默认的笔记内容 12345componentDidMount() &#123; this.setState(&#123; noteContent: this.props.noteDetail.content // 这是从上一个页面传递过来的值 &#125;);&#125; TextInput属性介绍123456789&lt;TextInput style=&#123;[styles.noteDetailContent, &#123;height: this.state.height&#125;]&#125; multiline=&#123;true&#125; secureTextEntry=&#123;false&#125; underlineColorAndroid=&#123;'transparent'&#125; value=&#123;this.state.noteContent&#125; onChangeText=&#123;(noteContent) =&gt; this.setState(&#123;noteContent&#125;)&#125; onChange=&#123;() =&gt; this.onChange.bind(this)&#125; onContentSizeChange=&#123;(event) =&gt; this.onContentSizeChange(event)&#125;/&gt; onChange function 监听方法,文本框内容发生改变回调方法 12345onChangeText = (text) =&gt; &#123; this.setState(&#123; noteContent: text &#125;)&#125; onChangeText function监听方法，文本框内容发生改变回调方法，该方法主要是监听输入框文字的变化 12345onChange = (event) =&gt; &#123; this.setState(&#123; noteContent: event.nativeEvent.text &#125;);&#125;; onContentSizeChange function监听方法，当文本框的高度发生变化时回调该方法。当TextInput的高度可变时，调用onLayout方法并将宽高传递给它，并重新绘制该组件。 12345onContentSizeChange = (event) =&gt; &#123; this.setState(&#123; height: event.nativeEvent.contentSize.height &#125;);&#125; 至此就大功告成了！有什么问题可留言交流]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 自定义组件]]></title>
    <url>%2F2017%2F06%2F21%2FReact%20Native%2FReact%20Native%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[通过继承Component来创建组件类 123class TextButton extends Component &#123;&#125; 定义组件的propTypes(props类型)和defaultProps(props默认值) 12345678910111213static propTypes = &#123; text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number &#125;; static defaultProps = &#123; color: 'white', backgroundColor: '#FFDE00', fontSize:14 &#125;; 其中PropTypes的类型有：array，bool，func，number，object， string，symbol 渲染界面，引用props值 123456789render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this.props.onPress&#125;&gt; &lt;View style=&#123;[&#123;backgroundColor:this.props.backgroundColor&#125;]&#125;&gt; &lt;Text style=&#123;&#123;fontSize:this.props.fontSize, color:this.props.color&#125;&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125; 导出组件 1export default TextButton; 下面是完整代码：12345678910111213141516171819202122232425262728293031323334353637'use strict'; import React, &#123;Component, PropTypes&#125; from 'react';import &#123; StyleSheet, TouchableOpacity, Text, View&#125; from 'react-native'; class TextButton extends Component &#123; static propTypes = &#123; text: PropTypes.string.isRequired, onPress: PropTypes.func, color: PropTypes.string, backgroundColor:PropTypes.string, fontSize: PropTypes.number &#125;; static defaultProps = &#123; color: 'white', backgroundColor: '#FFDE00', fontSize:14 &#125;; render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this.props.onPress&#125;&gt; &lt;View style=&#123;[&#123;backgroundColor:this.props.backgroundColor&#125;]&#125;&gt; &lt;Text style=&#123;&#123;fontSize:this.props.fontSize, color:this.props.color&#125;&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; export default TextButton; 引用123456789//首先导入组件import TextButton from '../component/TextButton';//然后在render渲染&lt;TextButton style=&#123;styles.register&#125; text=&#123;'测试文字'&#125; onPress=&#123;() =&gt; this._test()&#125; color=&#123;'#FFDE00'&#125; backgroundColor=&#123;'transparent'&#125;/&gt;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova插件开发-Android获取资源Id]]></title>
    <url>%2F2017%2F06%2F10%2FAngularJs%2FgetResourcesId%2F</url>
    <content type="text"><![CDATA[在制作Cordova插件时不能通过R文件来寻找资源Id，因为R文件是不断变化的，所以我们必须要通过资源名称来获取Id，下面就介绍一下资源id的获取: 使用Resources 类的 getIdentifier方法 ① 通过资源名称虚招布局文件的id 12345private int getResId(String resourceName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(resourceName,"layout",getPackageName()); return resId;&#125; ② 获取字符串id 12345private int getStringId(String stringName)&#123; Resources resources = getResources(); int resId =resources.getIdentifier(stringName,"string", getPackageName()); return resId;&#125; ③ 获取控件id 12345private int getId(String idName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(idName, "id", getPackageName()); return resId;&#125; ④ 获取动画id 12345private int getAnimId(String idName)&#123; Resources resources = getResources(); int resId = resources.getIdentifier(idName, "anim", getPackageName()); return resId;&#125; 作为一个Android开发者来说，也许你已经发现上面代码的不同点了，就是getIdentifier()里面的第二个参数的不同，我们可以通过替换这个参数来达到大部分的寻找资源id``（example：id, string, anim, attr, drawable, layout, color, menu, styles...） 通过Java的强大的反射机制获取资源id ① 通过反射获取一个资源id 12345678910111213141516public int getAttrId(String attrName) &#123; try &#123; Class&lt;?&gt; loadClass = mContext.getClassLoader().loadClass(mContext.getPackageName() + ".R"); Class&lt;?&gt;[] classes = loadClass.getClasses(); for (int i = 0; i &lt; classes.length; i++) &#123; if (classes[i].getName().equals(mContext.getPackageName() + ".R$attr")) &#123; Field field = classes[i].getField(attrName); int attrId = field.getInt(null); return attrId; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0; &#125; ② 首先使用反射能达到上面的获取一个id的情况，但是比较麻烦，当需要返回一个数组我们就不得不使用这种方法了 123456789101112131415161718192021private int[] getStyleableArryId(String styleableName)&#123; try &#123; Class&lt;?&gt; loadClass = getContext().getClassLoader().loadClass(getContext().getPackageName() + ".R"); Class&lt;?&gt;[] classes = loadClass.getClasses(); for(int i=0 ;i&lt;classes.length ;i++)&#123; Class&lt;?&gt; resClass = classes[i]; if(resClass.getName().equals(getContext().getPackageName() + ".R$styleable"))&#123; Field[] fields = resClass.getFields(); for (int j = 0; j &lt; fields.length; j++) &#123; if(fields[j].getName().equals(styleableName))&#123; int[] styleable = (int[]) fields[j].get(null); return styleable; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 但是在设置styleable的资源id的时候，如果你是自定义的View，如果需要引入自定义的attr,比如这样：1234public WheelVerticalView(Context context, final AttributeSet attrs) &#123; this(context, attrs, R.attr.abstractWheelViewStyle); this(context, attrs, 0);&#125; 那么你是不能通过上面的方法，来获取资源文件的，因为这是一个构造器，你只能另找它法了。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native网络请求和Json-String封装]]></title>
    <url>%2F2017%2F05%2F20%2FReact%20Native%2FReact%20Native%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Serialization 通过以下实例我们实现 Json与String、Json与Map的数据转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'use strict';import React, &#123;Component&#125; from 'react'; class JsonUtil extends Component &#123; /* * 字符转换为JSON * */ static strToJson(data) &#123; return JSON.parse(data); &#125; /* * JSON转换为字符 * */ static jsonToStr(data) &#123; return JSON.stringify(data); &#125; /* * map转换为json * */ static mapToJson(map) &#123; return JSON.stringify(JsonUtil.strMapToObj(map)); &#125; /* * json转换为map * */ static jsonToMap(jsonStr) &#123; return JsonUtil.objToStrMap(JSON.parse(jsonStr)); &#125; /* * map转化为对象（map所有键都是字符串，可以将其转换为对象） * */ static strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return obj; &#125; /* * 对象转换为Map * */ static objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap; &#125;&#125; export default JsonUtil; 网络请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495'use strict';import React, &#123;Component&#125; from 'react';class NetUtil extends Component &#123;static DouB_Api = 'https://api.douban.com/v2/movie/top250?start=0&amp;count=20';/** * get请求 *url : 请求地址 *callback : 回调函数 */static get(url, callback) &#123; var fetchOptions = &#123; method: 'GET', headers: &#123; 'X-LC-Id': 'M401fErHUKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt1LvQh1JDRUpRAqq' &#125; &#125;; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)); &#125;).done();&#125;/** * delete请求 *url : 请求地址 *callback : 回调函数 */static delete(url, callback) &#123; var fetchOptions = &#123; method: 'DELETE', headers: &#123; 'X-LC-Id': 'M401fErHUKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt1LvQh1JDRUpRAqq' &#125; &#125;; fetch(url, fetchOptions) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)); &#125;).done();&#125;/** * post请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */static postJson(url, data, callback) &#123; var fetchOption = &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'X-LC-Id': 'M401fErHDKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt34vQh1JDRUpRAqq' &#125;, body: JSON.stringify(data) &#125;; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)) &#125;) .done();&#125;/** * put请求 * url : 请求地址 * data : 参数(Json对象) * callback : 回调函数 * */static putJson(url, data, callback) &#123; var fetchOption = &#123; method: 'PUT', headers: &#123; 'Content-Type': 'application/json', 'X-LC-Id': 'M401fErHUPKmgp0wjqVRX-gzGzoHsz', 'X-LC-Key': 'Jqnvt34vQh1JDRUpRAqq' &#125;, body: JSON.stringify(data) &#125;; fetch(url, fetchOption) .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; callback(JSON.parse(responseText)) &#125;) .done();&#125;export default NetUtil; 网络请求使用123456789101112131415161718import NetUtil from '../utils/NetUtil';import JsonUtil from '../utils/JsonUtil'; _getMyNoteBook = () =&gt; &#123; let _this = this; let username = this.state.username; let params = &#123; "author": username &#125;; let url = Global.NOTEBOOK + JsonUtil.jsonToStr(params); NetUtil.get(url, function (response) &#123; console.log(response); _this.setState(&#123; notebooks: _this.state.notebooks.cloneWithRows(response.results), noteArray: response.results &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs固定大小的图片防止变形]]></title>
    <url>%2F2017%2F05%2F15%2FAngularJs%2FimageCover%2F</url>
    <content type="text"><![CDATA[使用情景：当我们遇到需要固定大小的图片，而又不想让图片变形 这个时候我要应该要想到的是css中的background相关属性 12345.backImg &#123; 'background-image': 'url('')', 'background-size': 'cover', 'background-position': 'center'&#125; 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分可能无法显示在背景定位区域中。这样我们就可以让图片局部显示并达到了图片没有变形的效果 下面是AngularJs把它封装为相应的指令 12345678910111213angular.module('imgTransformModule', []) .directive('imgTransform', function () &#123; return function (scope, element, attrs) &#123; attrs.$observe('imgTransform', function (value) &#123; element.css(&#123; 'background-image': 'url(' + value + ')', 'background-size': 'cover', 'background-position': 'center' 'display':'inline-block'; &#125;); &#125;); &#125;; &#125;); 调用 1&lt;div class="img-Transform" img-transform="&#123;&#123;url&#125;&#125;"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova修改相册插件和监听Android返回]]></title>
    <url>%2F2017%2F05%2F10%2FAngularJs%2Fionic%E7%9B%91%E5%90%ACAndroid%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[ionic混合开发调用Android系统相册，官方的cordova-image-picker插件在直接用的时候会在Android6.0以上的版本由于没有获得相应的存储权限而闪退。 解决方法一： 在原有的cordova插件上面改动，添加了动态授权，我放在了github 用法和原来的相同。 12345678910111213141516171819function getImgPicker() &#123; var options = &#123; maximumImagesCount: 1, width: 800, height: 800, quality: 80, title:'', message:'', outputType:1 &#125;; window.imagePicker.getPictures(function (results) &#123; vm.userInfo.Url = results[0]; console.log(vm.userInfo.Url); vm.upload(vm.userInfo.Url); &#125;, function (err) &#123; publicMethod.showLoadingNoBackdrop('调取相册失败'); console.log(angular.toJson(error, true)); &#125;, options);&#125; 解决方法二： 添加一个新的插件，专门获取所需的权限cordova-plugin-android-permissions，下面是用法。 12345678910111213141516var permissions = cordova.plugins.permissions;permissions.hasPermission(permissions.CAMERA, checkPermissionCallback, null); function checkPermissionCallback(status) &#123; if(!status.hasPermission) &#123; var errorCallback = function() &#123; console.warn('Camera permission is not turned on'); &#125; permissions.requestPermission( permissions.CAMERA, function(status) &#123; if(!status.hasPermission) errorCallback(); &#125;, errorCallback); &#125;&#125; ionic 监听Android的返回键和双击退出程序(直接上代码) 12345678910111213141516171819202122232425262728293031$ionicPlatform.registerBackButtonAction(function (e) &#123; e.preventDefault(); //判断处于哪个页面时双击退出 if ($location.path() == '/tab/home' || $location.path() == '/tab/activity' || $location.path() == '/tab/person' || $location.path() == '/tab/share' || $location.path() == '/tab/study') &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else &#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show("再按一次退出系统", "short", "bottom"); $timeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; else if ($location.path() == '/blueprint-list' || $location.path() == '/megagame-list') &#123; $state.go('tab.activity'); //此处判断当前所处的View,并返回到tab页 &#125; else if ($ionicHistory.backView()) &#123; $ionicHistory.goBack(); &#125; else &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else &#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.show("再按一次退出系统", "short", "bottom"); $timeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; return false;&#125;, 101);]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac跨域]]></title>
    <url>%2F2017%2F04%2F22%2Ffront%2FMac%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Mac： chrome49以前版本 1open -a "Google Chrome" --args --disable-web-security chrome49以后版本 1open -a /Applications/Google\ Chrome.app --args --disable-web-security --user-data-dir Safari 1open -a '/Applications/Safari.app' --args --disable-web-security Window： chrome.exe –disable-web-security PS：Mac–&gt;Chrome如果命令行不成功可以安装一个插件Allow-Control-Allow-Origin]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 博客搭建资源整理]]></title>
    <url>%2F2017%2F04%2F01%2Ffront%2FHexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Next Theme版本5.1.0 hexo博客搭建遇到的问题处理和优化所需的资源 hexo开始搭建 底部Powered By algolia问题 三方服务 Cannot find module ‘hexo-util’ 配置文件属性说明 集成LeanCloud记录次数 hexo next 底部Logo栏(powered by) 添加友言评论 Hexo异常处理 主题配置 Hexo 持续优化(二) Hexo 持续优化(一) daovoice hexo 大小写404问题]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
